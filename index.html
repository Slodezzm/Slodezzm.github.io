<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-前端一些常见面试问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/前端一些常见面试问题/" class="article-date">
  <time datetime="2017-07-11T12:49:59.452Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="j��һЩ������������"><a href="#j��һЩ������������" class="headerlink" title="ǰ��һЩ������������"></a>ǰ��һЩ������������</h1><p>###1. w3c��׼����</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">��ά�����˴�����<span class="number">1994</span>�꣬��Web������������Ȩ����Ӱ�����Ĺ��������Լ�����׼��������ĿǰΪֹ��W3C�ѷ�����<span class="number">200</span>����Ӱ����Զ��Web������׼��ʵʩָ�ϣ�����Ϊҵ�����õĳ��ı��������ԣ���׼ͨ�ñ��������µ�һ��Ӧ�ã�������չ�������ԣ���׼ͨ�ñ��������µ�һ���Ӽ����Լ�����������ʿ��Ч����Web���ݵ���Ϣ���ϰ�ָ�ϣ�WCAG���ȣ���Ч�ٽ���Web�����Ļ������ݣ��Ի����������ķ�չ��Ӧ�������˻����Ժ͸����Ե�֧�����á�[<span class="number">1</span>]��ά�����ˣ�������д��W3C����׼����ĳһ����׼������һϵ�б�׼�ļ��ϡ���ҳ��Ҫ�����������ɣ��ṹ��Structure�������֣�Presentation������Ϊ��Behavior����</div><div class="line"></div><div class="line">w3c��Ҫ��web�Ĺ淶����Ҫ�Ĺ淶��������:</div><div class="line">�ṹ��׼����: </div><div class="line">	һ������չ�������� XML1<span class="number">.0</span></div><div class="line">    ��������չ���ı��������� XHTML</div><div class="line">�ṹ��HTML �������ĽǶȣ�����ҳ���Ľṹ</div><div class="line">���ֱ�׼����:</div><div class="line">	��ʽ��css �������ĽǶȣ�����ҳ��</div><div class="line">��Ϊ��javascript �ӽ����ĽǶ���ʾ�û�����</div></pre></td></tr></table></figure>
<p>###2. html5����:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  �������ԣ�Class��Semantic��HTML5������ҳ���õ������ͽṹ�����ӷḻ�ı�ǩ�����Ŷ�RDFa�ģ�΢������΢��ʽ�ȷ�����֧�֣������Գ��򡢶��û������м�ֵ������������Web��</div><div class="line"></div><div class="line">���ش洢���ԣ�Class: OFFLINE &amp; STORAGE��</div><div class="line">����HTML5��������ҳAPPӵ�и��̵�����ʱ�䣬�����������ٶȣ���Щȫ������HTML5 APP Cache���Լ����ش洢���ܡ�Indexed DB��html5���ش洢����Ҫ�ļ���֮һ����API˵���ĵ���</div><div class="line"></div><div class="line">�豸�������� (Class: DEVICE ACCESS)</div><div class="line">��Geolocation���ܵ�API�ĵ�����������HTML5Ϊ��ҳӦ�ÿ��������ṩ�˸��๦���ϵ��Ż�ѡ�񣬴����˸������鹦�ܵ����ơ�HTML5�ṩ��ǰ��δ�е�������Ӧ�ý��뿪�Žӿڡ�ʹ�ⲿӦ�ÿ���ֱ�����������ڲ�������ֱ��������������ƵӰ����ֱ����microphones������ͷ������</div><div class="line"></div><div class="line">�������ԣ�Class: CONNECTIVITY��</div><div class="line">����Ч�����ӹ���Ч�ʣ�ʹ�û���ҳ����ʵʱ���죬�����ٵ���ҳ��Ϸ���飬���Ż������߽����õ���ʵ�֡�HTML5ӵ�и���Ч�ķ��������ͼ�����Server-Sent Event��WebSockets�������е��������ԣ������������ܹ���������ʵ�ַ����������ݡ����͡����ͻ��˵Ĺ��ܡ�</div><div class="line"></div><div class="line">��ҳ��ý������(Class: MULTIMEDIA)</div><div class="line">֧����ҳ�˵�Audio��Video�ȶ�ý�幦�ܣ� ����վ�Դ���APPS������ͷ��Ӱ�������������á�</div><div class="line"></div><div class="line">��ά��ͼ�μ���Ч���ԣ�Class: <span class="number">3</span>D, Graphics &amp; Effects��</div><div class="line">����SVG��Canvas��WebGL��CSS3��<span class="number">3</span>D���ܣ��û��ᾪ̾�����������У������ֵľ����Ӿ�Ч����</div><div class="line"></div><div class="line">�����뼯�����ԣ�Class: Performance &amp; Integration��</div><div class="line">û���û�����Զ�ȴ�����Loading����HTML5��ͨ��XMLHttpRequest2�ȼ�������������WebӦ�ú���վ�ڶ������Ļ����и����ٵĹ�����</div></pre></td></tr></table></figure></p>
<p>###CSS3����(Class: CSS3)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">�ڲ��������ܺ������ṹ��ǰ���£�CSS3���ṩ�˸����ķ����͸�ǿ��Ч�������⣬��֮��ǰ��Web�Ű棬Web�Ŀ���������ʽ��WOFF��Ҳ�ṩ�˸��ߵ������ԺͿ����ԡ�</div><div class="line"><span class="number">1.</span>   CSS3ʵ��Բ�ǣ�border-radius������Ӱ��box-shadow����</div><div class="line"><span class="number">2.</span>    �����ּ���Ч��text-shadow���������Խ��䣨gradient������ת��transform��</div><div class="line"><span class="number">3.</span>    transform:rotate(<span class="number">9</span>deg) scale(<span class="number">0.85</span>,<span class="number">0.90</span>) translate(<span class="number">0</span>px,<span class="number">-30</span>px) skew(<span class="number">-9</span>deg,<span class="number">0</span>deg);<span class="comment">// ��ת,����,��λ,��б</span></div><div class="line"><span class="number">4.</span>    �����˸�����CSSѡ����  �౳�� rgba </div><div class="line"><span class="number">5.</span>    ��CSS3��Ψһ������αԪ���� ::selection.</div><div class="line"><span class="number">6.</span>    ý����ѯ����������</div><div class="line"><span class="number">7.</span>    border-image</div></pre></td></tr></table></figure></p>
<p>###3. seo�Ż�<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)��վ�ṹ�����Ż��������򵥡����ż�ɽ���ᳫ��ƽ���ṹ��</div><div class="line"><span class="number">1.</span> ������ҳ��������</div><div class="line">����վ��ҳ��Ȩ�����ߵĵط���������ҳ����̫�٣�û�С��š�����֩�롱���ܼ�������������ҳ��ֱ��Ӱ����վ��¼������������ҳ����Ҳ����̫�࣬һ��̫�࣬û��ʵ���Ե����ӣ�������Ӱ���û����飬Ҳ�ή����վ��ҳ��Ȩ�أ���¼Ч��Ҳ���á�</div><div class="line">�������˶�����С����ҵ��վ��������ҳ������<span class="number">100</span>�����ڣ����ӵ����ʿ��԰���ҳ�浼�����ײ�������ê�������ӵȵȣ�ע������Ҫ�������û������������������û���ȡ��Ϣ�Ļ���֮�ϡ�</div><div class="line">����</div><div class="line"><span class="number">2.</span>��ƽ����Ŀ¼���Σ������á�֩�롱ֻҪ��ת<span class="number">3</span>�Σ����ܵ�����վ�ڵ��κ�һ����ҳ����ƽ����Ŀ¼�ṹ�����磺��ֲ�--&gt; <span class="string">"ˮ��"</span> --&gt; <span class="string">"ƻ��"</span>�������ӡ������㽶����ͨ��<span class="number">3</span>�������ҵ��㽶�ˡ�</div><div class="line"></div><div class="line"><span class="number">3.</span>�����Ż�</div><div class="line">��������Ӧ�þ����������ַ�ʽ��Ҳ���Դ���ͼƬ����������ͼƬ����һ��Ҫ�����Ż���&lt;img&gt;��ǩ�������ӡ�alt���͡�title�����ԣ������������浼���Ķ�λ��������ʹͼƬδ��������ʾʱ���û�Ҳ�ܿ�����ʾ���֡�</div><div class="line">�������Σ���ÿһ����ҳ��Ӧ�ü�������м�������ô������û����鷽����˵���������û��˽⵱ǰ������λ���Լ���ǰҳ����������վ�е�λ�ã������û��ܿ��˽���վ��֯��ʽ���Ӷ��γɸ��õ�λ�øУ�ͬʱ�ṩ�˷��ظ���ҳ���Ľӿڣ������û��������ԡ�֩�롱���ԣ��ܹ��������˽���վ�ṹ��ͬʱ�������˴������ڲ����ӣ�����ץȡ�����������ʡ�</div><div class="line">����</div><div class="line"><span class="number">4.</span> ��վ�Ľṹ����--���ɺ��Ե�ϸ��</div><div class="line">����ҳ��ͷ����logo�����������Լ��û�����Ϣ��</div><div class="line">����ҳ�����壺�������ģ���������м���������ģ��ұ߷��������¼��������£��ô�����ס�ÿͣ��÷ÿͶ�ͣ�����ԡ�֩�롱���ԣ���Щ���������������ӣ���ǿ��ҳ�������ԣ�Ҳ����ǿҳ����Ȩ�ء�</div><div class="line">����ҳ���ײ�����Ȩ��Ϣ���������ӡ�</div><div class="line">�����ر�ע�⣺��ҳ����д�����Ƽ�д��������ҳ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> �����򡱣�������֩�롱�ܹ�������Ӧҳ��ֱ����ת��������ֱ��ѡ��ҳ����ת����������д���ǲ��Ƽ��ģ�����ҳ ��һҳ βҳ�����ر��ǵ���ҳ�����ر���ʱ����֩�롱��Ҫ�����ܶ���������������ץȡ�������ۡ������׷�����</div><div class="line">����</div><div class="line"><span class="number">5.</span>����ҳ���Ĵ�С������http������������վ�ļ����ٶȡ�</div><div class="line">����һ��ҳ�����ò�Ҫ����<span class="number">100</span>k��̫����ҳ�������ٶ��������ٶȺ���ʱ���û����鲻�ã�����ס�ÿͣ�����һ����ʱ����֩�롱Ҳ���뿪</div><div class="line">����</div><div class="line">(<span class="number">2</span>)��ҳ�����Ż�</div><div class="line">	<span class="number">1.</span>&lt;title&gt;���⣺ֻǿ���ص㼴�ɣ���������Ҫ�Ĺؼ��ʷ���ǰ�棬�ؼ��ʲ�Ҫ�ظ����֣���������ÿ��ҳ����&lt;title&gt;�����в�Ҫ������ͬ�����ݡ�</div><div class="line"></div><div class="line">����<span class="number">2.</span>&lt;meta keywords&gt;��ǩ���ؼ��ʣ��оٳ�����ҳ������Ҫ�ؼ��ּ��ɣ��мǹ��ֶ�����</div><div class="line"></div><div class="line">����<span class="number">3.</span>&lt;meta description&gt;��ǩ����ҳ��������Ҫ�߶ȸ�����ҳ���ݣ��мǲ���̫�������ֶ����ؼ��ʣ�ÿ��ҳ��ҲҪ������ͬ��</div><div class="line"></div><div class="line">����<span class="number">4.</span>&lt;body&gt;�еı�ǩ�������ô������廯�����ʵ���λ��ʹ���ʵ��ı�ǩ������ȷ�ı�ǩ����ȷ���¡����Ķ�Դ���ߺ͡�֩�롱��һĿ��Ȼ�����磺h1-h6 �����ڱ������ģ�&lt;nav&gt;��ǩ����������ҳ���������ĵȡ�</div><div class="line">����</div><div class="line">����<span class="number">5.</span>&lt;a&gt;��ǩ��ҳ�����ӣ�Ҫ�� ��title�� ���Լ���˵�����÷ÿͺ� ��֩�롱 ֪�������ⲿ���ӣ����ӵ�������վ�ģ�����Ҫ���� el=<span class="string">"nofollow"</span> ����, ���� ��֩�롱 ��Ҫ������Ϊһ����֩�롱�����ⲿ����֮�󣬾Ͳ����ٻ����ˡ�</div><div class="line"></div><div class="line">����<span class="number">6.</span>���ı���Ҫ��&lt;h1&gt;��ǩ����֩�롱 ��Ϊ������Ҫ������ϲ��&lt;h1&gt;��Ĭ����ʽ����ͨ��CSS���á������������ı�����&lt;h1&gt;��ǩ����������&lt;h2&gt;��ǩ, �������ط���Ӧ���������� h ������ǩ��</div><div class="line"></div><div class="line">	<span class="number">7.</span>&lt;br&gt;��ǩ��ֻ�����ı����ݵĻ���</div><div class="line">    </div><div class="line">	<span class="number">8.</span>����Ӧ��ʹ��&lt;caption&gt;����������ǩ</div><div class="line"></div><div class="line"> ��  <span class="number">9.</span>&lt;img&gt;Ӧʹ�� <span class="string">"alt"</span> ���Լ���˵��</div><div class="line"></div><div class="line">����<span class="number">10.</span>&lt;strong&gt;��&lt;em&gt;��ǩ : ��Ҫǿ��ʱʹ�á�&lt;strong&gt;��ǩ�������������ܹ��õ��߶ȵ����ӣ�����ͻ���ؼ��ʣ�������Ҫ�����ݣ�&lt;em&gt;��ǩǿ��Ч��������&lt;strong&gt;��ǩ��</div><div class="line"></div><div class="line">������  &lt;b&gt;��&lt;i&gt;��ǩ: ֻ��������ʾЧ��ʱʹ�ã���SEO�в������κ�Ч����</div><div class="line"></div><div class="line">����<span class="number">10</span>���ı�������Ҫʹ���������� &amp;nbsp; Ӧ��ʹ��CSS�������á���Ȩ���Ų�Ҫʹ���������� &amp;copy; ����ֱ��ʹ�����뷨��ƴ��banquan����ѡ������<span class="number">5</span>���ܴ�����Ȩ����?��</div><div class="line"></div><div class="line">����<span class="number">12</span>����������CSS���֣�����Ҫ���ݵ�HTML����������ǰ�棬��ǰ�������ݱ���Ϊ������Ҫ�ģ������á�֩�롱��ȡ���������ݹؼ���ץȡ��</div><div class="line"></div><div class="line">����<span class="number">13.</span>��Ҫ���ݲ�Ҫ��JS��������Ϊ��֩�롱����ʶ</div><div class="line"></div><div class="line">����<span class="number">14.</span>������ʹ��iframe����,��Ϊ��֩�롱һ�㲻����ȡ���е�����</div><div class="line"></div><div class="line">����<span class="number">15.</span>����ʹ�� display��none �����ڲ�����ʾ���������ݣ�Ӧ������z-index�����õ���������ʾ��֮�⡣��Ϊ�������������˵�display:none���е����ݡ�</div><div class="line"></div><div class="line">����<span class="number">16.</span> ���Ͼ�������</div><div class="line"></div><div class="line">����<span class="number">17.</span>js���������ǲ���DOM������Ӧ��������body������ǩ֮ǰ��html����֮����</div></pre></td></tr></table></figure></p>
<p>###4. node����:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Node��������V8 JavaScript��V8 JavaScript������Google������Chrome�������ĵײ�JavaScript���档Googleʹ��V8������һ����C++��д�ĳ������������ý�����ӵ����һ���������������������ظ����沢����Ƕ���κ�Ӧ�ó�����V8 JavaScript���沢����������һ�������������С����ˣ�Node.jsʵ���ϻ�ʹ��Google��д��V8 JavaScript���棬�������ؽ�Ϊ���ڷ�������ʹ�á�</div><div class="line">Node.js�ŵ㣺</div><div class="line"><span class="number">1</span>�������¼��������첽���̣�Ϊ�������������ơ���ʵJavascript�����������ͱհ����Էǳ��ʺ��¼��������첽���̡�����JavaScriptҲ������ѧ���ܶ�ǰ��������Ա���Ժܿ��������������ơ�</div><div class="line"><span class="number">2</span>��Node.js������ģʽ��IO������Node.js���������Ե�ϵͳ��Դ�����µĸ����������ڵĸ����������ǳ��ʺ�������������IO��Դ���м���������</div><div class="line"><span class="number">3</span>��Node.js������Ч��������Ϊ�������ܼ��ͷֲ�ʽ���𻷾��µ�ʵʱӦ��ϵͳ����������������Node�ǳ��ʺ���������������Ӧ�ͻ���֮ǰ����Ԥ�ƿ����кܸߵ��������������ķ��������߼��ʹ�����һ���ܶࡣ</div><div class="line">Node.jsȱ�㣺</div><div class="line"><span class="number">1</span>���ɿ��Ե�</div><div class="line"><span class="number">2</span>�������̣����̣߳�ֻ֧�ֵ���CPU�����ܳ��ֵ����ö���CPU��������һ���������̱�������ô����web�����ͱ����ˡ�</div></pre></td></tr></table></figure></p>
<p>###5.Angular����:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	Angular JS (Angular.JS) ��һ����������Webҳ���Ŀ��ܡ�ģ���Լ����ݰ󶨺ͷḻUI��������֧�������������̣��ṩwebӦ�õļܹ������������ֹ�DOM������ AngularJS��С��ֻ��<span class="number">60</span>K�������������������� jQuery �������á�</div><div class="line">	</div><div class="line">����һ��˫�����ݰ���</div><div class="line">	���ݰ󶨿�����AngularJS������ʵ�õ����ԡ����ܹ�������������д�����ĳ�ʼ�����Ӷ���Լ����ʱ�䡣һ�����͵�webӦ�ÿ��ܰ�����<span class="number">80</span>%�Ĵ���������������ѯ�ͼ���DOM�����ݰ���ʹ�ô������٣�������רע������Ӧ�á�</div><div class="line">	</div><div class="line">���Զ���ģ��</div><div class="line">	��AngularJS�У�һ��ģ������һ��HTML�ļ�������HTML��������չ�ˣ������˺ܶ�������ӳ��model��view�����ݡ�</div><div class="line">	HTMLģ�彫�ᱻ������������DOM�С�DOMȻ����ΪAngularJS�����������롣AngularJS��������DOMģ��������һЩָ��������directive��ָ������е�ָ���������view���������ݰ󶨡�</div><div class="line">	</div><div class="line">��������MVC</div><div class="line">	���Կͻ���Ӧ�ÿ���AngularJS�����˴�ͳ��MVC����ԭ����MVC����Model-View-Controll����ģʽ���Բ�ͬ���˿�����ζ��ͬ�Ķ�����AngularJS����ִ�д�ͳ�����ϵ�MVC�����ӽ���MVVM��Model-View-ViewModel)��</div><div class="line">	</div><div class="line">�����ģ�����ע�루Dependency Injection����DI��</div><div class="line">	AngularJSӵ���ڽ�������ע����ϵͳ�����԰���������Ա�����׵Ŀ����������Ͳ���Ӧ�á�</div><div class="line">DI���������������������������Լ���Ѱ���ǡ����磬������Ҫһ��������DI�����Ҵ��������ṩ�����ǡ�</div><div class="line">	</div><div class="line">�����壺Directives��ָ�</div><div class="line">	AngularJS ָ������ʹ�� HTML ���﷨���ٵĹ���Ӧ�ó����������Դ��������õ��Զ���������ָ����API��Angularjs ������һЩָ�����ng-app ng-controller ng-mode, ng-repeat, ng-show�ȡ���Щָ�����DOMԪ���ض�����Ϊ;</div></pre></td></tr></table></figure></p>
<p>###6.˫������:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">angular: ��ֵ����</div><div class="line">	ÿһ��ָ�����һ����Ӧ�������۲����ݵĶ��󣬽���watcher��һ���������л��кܶ���watcher��ÿ��������Ҫ����ʱ��Angular��������ǰ��������������watcher��������һһ��ֵ��Ȼ����֮ǰ�����ľ�ֵ���бȽϡ�������ֵ�Ľ����仯�ˣ��ʹ�����Ӧ�ĸ��£��������̽���digest cycle�����������������⣺</div><div class="line"></div><div class="line"><span class="number">1.</span>�κ����ݱ䶯����ζ�ŵ�ǰ��������ÿһ��watcher��Ҫ��������ֵ�����˵�watcher�������Ӵ�ʱ��Ӧ�õ����ܾͲ��ɱ������ܵ�Ӱ�죬���Һ����Ż���</div><div class="line"><span class="number">2.</span>�����ݱ䶯ʱ�����ܲ������������⵽�仯�ķ�������Ҫ�ֶ�����digest cycle���ܴ�����Ӧ��DOM ���¡�Angularͨ����DOM�¼������������Զ�����digest cycle���ֹ������������⣬�������кܶ�������Ҫ�û��ֶ����д�������</div><div class="line">    </div><div class="line">vue: ���ݽٳ�</div><div class="line">	 Vue.js������ES5��<span class="built_in">Object</span>.defineProperty������ֱ�ӽ�ԭ�����ݶ��������Ը���Ϊgetter��setter���������������ڲ�ʵ���������ռ��ʹ�������������֧��Ƕ�׵Ķ����ṹ���������飬��ͨ�����������Ŀɱ䷽��������push�������������ı仯����ʹ�ò���Vue.js�����ݺͲ���ԭ�����󼸺�û�в���[ע:������/ɾ�����ԣ������޸������ض�λ��Ԫ��ʱ����Ҫ�����ض��ĺ�������obj.$add(key, value)���ܴ������¡�</div></pre></td></tr></table></figure></p>
<p>###7.·�ɻ���ԭ��:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ԭ��: ͨ���ı�URL hashֵ����·�ɵ��л�����̬����htmlģ��;</div><div class="line">��������ĳ��·��֮�󣬾������ĸ���������ʾ�ڵ�ǰ��ҳ����</div><div class="line"></div><div class="line">AngularJS��ǰ��·�ɣ�������ǰ��ָ����(ng-app)������·�ɹ���(routeProvider)��Ȼ��ͨ����ͬ��URL������(ng-app)�����ĸ�ҳ��(HTML)������Ⱦ��(ng-app)��ͼ(ng-view)�С�</div></pre></td></tr></table></figure></p>
<p>###8.����ģʽ:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> SPA: ��ҳWebӦ�ã�single page web application��SPA��</div><div class="line">����: </div><div class="line">	��ҳӦ�ó��� (SPA) �Ǽ��ص���HTML ҳ�沢���û���Ӧ�ó��򽻻�ʱ��̬���¸�ҳ����WebӦ�ó�����������һ��ʼ�����ر�����HTML��CSS��JavaScript�����еĲ�����������ҳ�������ɣ�����JavaScript�����ơ����ˣ��Ե�ҳӦ����˵ģ�黯�Ŀ����������Ե��൱��Ҫ��</div><div class="line">    </div><div class="line">�ŵ㣺 </div><div class="line"><span class="number">1.</span>����ǰ���˹�ע�㣬ǰ�˸���view�����˸���model����˾��ְ�� </div><div class="line"><span class="number">2.</span>������ֻ�ӿ��ṩ���ݣ�����չʾ�߼���ҳ���ϳɣ��������ܣ� </div><div class="line"><span class="number">3.</span>ͬһ�׺��˳������룬�����޸ļ���Web���桢�ֻ��� </div><div class="line"><span class="number">4.</span>�û������á��죬���ݵĸı䲻��Ҫ���¼�������ҳ�� </div><div class="line"><span class="number">5.</span>���Ի����϶����ݣ����ٷ�����ѹ�� </div><div class="line"><span class="number">6.</span>��ҳӦ��������һ���������洦���Է��ʡ�����������������Ӧ�ã��û�����ͨ�������������Ӻ��ʵ������������ʵ�ҳӦ�á���������һ�������������ֻ���ƽ�����ԡ����ӡ��ʼǱ����Ժ�̨ʽ�������� </div><div class="line"></div><div class="line">ȱ�㣺 </div><div class="line"><span class="number">1.</span>SEO����û��htmlץ����ʲô������ </div><div class="line"><span class="number">2.</span>�տ�ʼ��ʱ�����ؿ������ܶ� </div><div class="line"><span class="number">3.</span>�û�������Ҫд�߼���ǰ�������˵ȣ� </div><div class="line"><span class="number">4.</span>ҳ�渴�Ӷ����ߺܶ࣬�����߼��Ѷȳɱ�</div><div class="line"></div><div class="line"><span class="number">2.</span>MVC: AngularJS Backbone.js Ember.js</div><div class="line">	MVCȫ����Model View Controller����ģ��(model)����ͼ(view)��������(controller)����д��һ���������Ƶ䷶����һ��ҵ���߼������ݡ�������ʾ�����ķ�����֯���룬��ҵ���߼��ۼ���һ���������棬�ڸĽ��͸��Ի����ƽ��漰�û�������ͬʱ������Ҫ���±�дҵ���߼���MVC�����صķ�չ��������ӳ�䴫ͳ�����롢����������������һ���߼���ͼ�λ��û������Ľṹ�С�</div><div class="line"></div><div class="line">Model��ģ�ͣ���Ӧ�ó��������ڴ���Ӧ�ó��������߼��Ĳ��֡�ͨ��ģ�Ͷ������������ݿ��д�ȡ���ݡ�</div><div class="line">View����ͼ����Ӧ�ó����д���������ʾ�Ĳ��֡�ͨ����ͼ������ģ�����ݴ����ġ�</div><div class="line">Controller������������Ӧ�ó����д����û������Ĳ��֡�ͨ����������������ͼ��ȡ���ݣ������û����룬����ģ�ͷ�������</div><div class="line"></div><div class="line">�ŵ�</div><div class="line">��<span class="number">1</span>�����ȣ�����Ҫ��һ���Ƕ�����ͼ�ܹ���һ��ģ�͡�ͬһ��ģ�Ϳ��Ա���ͬ����ͼ���ã����������˴����Ŀ������ԡ�</div><div class="line">��<span class="number">2</span>������MVC������ģ���໥�������ı�����һ������Ӱ����������������������������˼���ܹ������õ������ϵĹ�����</div><div class="line">��<span class="number">3</span>�����⣬������������Ӧ�ó����������ԺͿ������ԡ������������������Ӳ�ͬ��ģ�ͺ���ͼȥ�����û�����������������������Ϊ����Ӧ�ó����ṩǿ�������ֶΡ�</div><div class="line"></div><div class="line">ȱ��:</div><div class="line">��<span class="number">1</span>��������ϵͳ�ṹ��ʵ�ֵĸ����ԡ�</div><div class="line">     ���ڼ򵥵Ľ��棬�ϸ���ѭMVC��ʹģ�͡���ͼ�����������룬�����ӽṹ�ĸ����ԣ������ܲ��������ĸ��²�������������Ч�ʡ�</div><div class="line">��<span class="number">2</span>����ͼ�����������Ĺ��ڽ��ܵ����ӡ�</div><div class="line">     ��ͼ�����������໥���룬��ȷʵ��ϵ���ܵĲ�������ͼû�п������Ĵ��ڣ���Ӧ���Ǻ����޵ģ���֮��Ȼ�������ͷ��������ǵĶ������á�</div><div class="line">��<span class="number">3</span>����ͼ��ģ�����ݵĵ�Ч�ʷ��ʡ�</div><div class="line">      ����ģ�Ͳ����ӿڵĲ�ͬ����ͼ������Ҫ���ε��ò��ܻ����㹻����ʾ���ݡ���δ�仯���ݵĲ���Ҫ��Ƶ�����ʣ�Ҳ���𺦲������ܡ�</div><div class="line">      </div><div class="line"><span class="number">3.</span>MVVM: vueJS avalonJS</div><div class="line">MVVM��Model-View-ViewModel�����ܵ���������MVP��Model-View-Presenter��ģʽ��WPF���ϵ�Ӧ�÷�ʽʱ��չ�ݱ�������һ�����ͼܹ����ܡ�</div><div class="line">�ŵ�:</div><div class="line"><span class="number">1.</span> �����ϡ���ͼ��View�����Զ�����Model�仯���޸ģ�һ��ViewModel���԰󶨵���ͬ��<span class="string">"View"</span>�ϣ���View�仯��ʱ��Model���Բ��䣬��Model�仯��ʱ��ViewҲ���Բ��䡣</div><div class="line"><span class="number">2.</span> �������ԡ������԰�һЩ��ͼ�߼�����һ��ViewModel���棬�úܶ�view����������ͼ�߼���</div><div class="line"><span class="number">3.</span> ����������������Ա����רע��ҵ���߼������ݵĿ�����ViewModel����������Ա����רע��ҳ�����ƣ�ʹ��Expression Blend���Ժ��������ƽ��沢����xml���롣</div><div class="line"><span class="number">4.</span> �ɲ��ԡ����������ǱȽ����ڲ��Եģ������ڲ��Կ�������ViewModel��д��</div></pre></td></tr></table></figure></p>
<p>###9.vue������:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">�ŵ�:</div><div class="line"><span class="number">1.</span>�������Ŀ���</div><div class="line"></div><div class="line"><span class="number">2.</span>˫�����ݰ���</div><div class="line">	��ֵ������Ҳ��ָ�ֻ��Ϊ�˷���ģ������д����ģ���ı��������У�Vue.js��Ϊÿһ����Ҫ��̬���µ�DOM�ڵ㴴��һ��ָ��������ÿ��һ��ָ�������۲������ݱ仯ʱ�������������󶨵�Ŀ���ڵ�ִ����Ӧ��DOM����������ָ�������ݰ���ʹ�þ�����DOM�������������ط�װ��ָ����У�ҵ������ֻ��Ҫ�漰ģ���Ͷ�����״̬�Ĳ������ɣ���ʹ��Ӧ�õĿ���Ч�ʺͿ�ά���Զ�����������</div><div class="line"></div><div class="line"><span class="number">3.</span>������</div><div class="line">	Vue.js�������н�������Ϊһ�����ĸ���</div><div class="line">	</div><div class="line"><span class="number">4.</span>�첽����DOM���£����������ݱ䶯ʱ�������ܵ�Ӱ����watcher�ᱻ���͵�һ�������У�����ÿ��watcherֻ���ƽ�����һ�Ρ��������л��ڽ��̵���һ�� ��tick�� �첽ִ�С��������ƿ��Ա���ͬһ�����ݶ��α䶯�����Ķ���DOM������Ҳ���Ա�֤���е�DOMд������һ��ִ�У�����DOM��д�л����ܵ��µ�layout��</div><div class="line"></div><div class="line"><span class="number">5.</span>����ϵͳ��Vue.js�ṩ�˼���ȴǿ���Ķ���ϵͳ����һ��Ԫ�صĿɼ��Ա仯ʱ���û��������Ժܼ򵥵ض�����Ӧ��CSS Transition��AnimationЧ�������������÷ḻ��JavaScript���Ӻ������и��ײ��Ķ���������</div><div class="line"></div><div class="line"><span class="number">6.</span>����չ�ԣ������Զ���ָ���������������Vue.js���ṩ��������mixin���ƣ����û������ڶ��������и��ù�ͬ�����ԡ�</div></pre></td></tr></table></figure></p>
<p>###10.AngularJS 2.0 &amp; 4.0����:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.0</span>: ���䶯 $scope���Ƴ�</div><div class="line"><span class="number">1.</span>�ƶ����µİ汾��רע���ƶ�Ӧ�õĿ������������������״������淽�������飬һ����ս�漰���ƶ������ܡ�����ʱ�䣩��ע���ⷽ����ʹ�����õ�������</div><div class="line"><span class="number">2.</span>ģ�黯������ģ�齫��Angular�ĺ������Ƴ����Ӷ����ø��õ����ܡ�����ζ��������ѡ������Ҫ��������</div><div class="line">�ִ�����Angular <span class="number">2.0</span>����ES6�͡����ࡱ�ִ����������Զ����µ����°汾����ΪĿ�ꡣ����ζ�ſ����߿���רע��ҵ���������صĴ��롣</div><div class="line"></div><div class="line"><span class="number">4.0</span>: </div><div class="line"><span class="number">1.</span>�ٶȸ��졢������С</div><div class="line">�����汾�����ٶȸ��졢������С����������ָ��NgFor��NgIf�Լ�ģ����source map�ȹ��ܽ������Ż���</div><div class="line"><span class="number">2.</span>��������</div><div class="line">�ð汾�������ݴ�����Ӧ���е�<span class="number">2.</span>x.xϵ�С�</div><div class="line"><span class="number">3.</span>ǿ���Ż�����</div><div class="line">�°汾���Ż���View���棬�Ľ���AoT���ɵĴ��뽫����Լ<span class="number">60</span>%������ģ��Խ���ӣ����Ż��Ĵ�������Խ����</div><div class="line"><span class="number">4.</span>�������ֵ�������</div><div class="line">Angular���������ִ�@angular/core���ֳ���������������������ģ�龫�������ڲ�ʹ�ö���ʱ��Ʒ�н������������Ķ������롣������Ҫ��������ʹ�����ع������е��롣</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/前端一些常见面试问题/" data-id="cj4zksgsa0009ykf404869hsi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端常用插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/前端常用插件/" class="article-date">
  <time datetime="2017-07-11T12:49:59.446Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端常用插件"><a href="#前端常用插件" class="headerlink" title="前端常用插件"></a>前端常用插件</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/前端常用插件/" data-id="cj4zksgsc000aykf4cpqlpk37" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端常见的兼容性问题及解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/前端常见的兼容性问题及解决方案/" class="article-date">
  <time datetime="2017-07-11T12:49:59.441Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端常见的兼容性问题及解决方案"><a href="#前端常见的兼容性问题及解决方案" class="headerlink" title="前端常见的兼容性问题及解决方案"></a>前端常见的兼容性问题及解决方案</h1><p>1.IE6中父元素浮动，如果宽度需要内容撑开，里面块级元素的内容也要加浮动<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;<span class="attribute">width</span>:<span class="number">400px</span>;&#125;</div><div class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">background</span>:red;<span class="attribute">float</span>:left;&#125;</div><div class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">background</span>:blue;<span class="attribute">float</span>:right;&#125;</div><div class="line"><span class="selector-tag">h3</span>&#123;<span class="attribute">height</span>:<span class="number">30px</span>;<span class="attribute">float</span>:left;&#125;</div></pre></td></tr></table></figure>
<p>2.IE6中p标签里面不要套用p标签或者h标签</p>
<p>3.IE6下最小高度问题：当元素的高度小于19px的时候会被当作19px来处理</p>
<ul>
<li>解决办法：overflow:hidden<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.box&#123;height:2px;background:red;overflow:hidden&#125;</div><div class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>3.浮动的div有margin_left属性ie6会加倍,无论兼容视图还是无声明视图</p>
<blockquote>
<p>解决方案:<br>　方案一: IE6唯一识别属性_的方式加_display属性_display:inline;<br>　方案二:条件注释<br>&lt;!–[if lte IE 6]&gt;</p>
<p><style><br>　　.on{ display:inline }<br></style><br>&lt;![endif]–&gt;</p>
</blockquote>
<p>4.png图片在IE6里面不能透明</p>
<ul>
<li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--[if IE ]&gt;</div><div class="line">　　　&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">　　　　　#DIVname&#123;</div><div class="line">　　　　　　　　background:none;</div><div class="line">　　　　　　　　filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=scale, src=&quot;pngtouming.png&quot;</div><div class="line">　　　　　&#125;</div><div class="line">　　　&lt;/style&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>5.渐变不兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColorStr=#35FEA1,endColorStr=#6E9DFF); /*IE 6 7 8*/</div><div class="line">    background: -ms-linear-gradient(top, #35FEA1,  #6E9DFF);/* IE 10 */</div><div class="line">    background:-moz-linear-gradient(top, #35FEA1,  #6E9DFF); /*火狐*/</div><div class="line">    background:-webkit-gradient(linear, 0% 0%, 0% 100%,from(#35FEA1), to(#6E9DFF));/*谷歌*/</div><div class="line">    background: -webkit-gradient(linear, 0% 0%, 0% 100%,from(#35FEA1), to(#6E9DFF));/* Safari 4-5, Chrome 1-9*/</div><div class="line">    background: -webkit-linear-gradient(top, #35FEA1,  #6E9DFF);/*Safari5.1 Chrome 10+*/</div><div class="line">    background: -o-linear-gradient(top, #35FEA1,  #6E9DFF);/*Opera 11.10+*/</div></pre></td></tr></table></figure></p>
<p> 6.display:inline-block ie6/7不支持</p>
<ul>
<li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> display:inline-block;</div><div class="line">*display:inline;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>7.默认的body没有body去掉margin情况下ie5、6、7边缘会很宽margin-top加倍,如果处于无声明状态那么所有的ie浏览器margin-top加倍</p>
<ul>
<li>解决方案，设置body的margin为0。</li>
</ul>
<p>8.min-height不兼容ie6/7，解释为超过高度就撑开，而其他版本浏览器则遮盖下面的层</p>
<ul>
<li>解决方案:min-height:200px; height:auto !important; height:200px; overflow:visible;</li>
</ul>
<p>9.position:fixed时IE5/6无法识别此属性</p>
<ul>
<li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">!--[if lte IE 6]&gt;</div><div class="line">　　　&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">　　　　　 html &#123;</div><div class="line">　　　　　　　　/*这个可以让IE6下滚动时无抖动*/</div><div class="line">　　　　　　　　background: url(about:black) no-repeat fixed</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　#demo_t, #demo_b, #demo_l, #demo_r &#123;</div><div class="line">　　　　　　　　position: absolute;</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　#demo_t, #demo_b &#123;</div><div class="line">　　　　　　　　/*这个解决body有padding时，IE6下100%不能铺满的问题*/</div><div class="line">　　　　　　　　width: expression(offsetParent.clientWidth);</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　/*下面三组规则用于IE6下top计算*/</div><div class="line">　　　　　　#demo_l, #demo_r &#123;</div><div class="line">　　　　　　　　top: expression(offsetParent.scrollTop + 300);</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　#demo_t &#123;</div><div class="line">　　　　　　　　top: expression(offsetParent.scrollTop);</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　　　#demo_b &#123;</div><div class="line">　　　　　　　　top: expression(offsetParent.scrollTop + offsetParent.clientHeight-offsetHeight);</div><div class="line">　　　　　　&#125;</div><div class="line">　　&lt;/style&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>10.父元素中的子元素大小超过父元素时父元素会被撑大</p>
<ul>
<li>解决方案：设置父元素overflow:hidden</li>
</ul>
<p>11.左浮元素margin-bottom失效 </p>
<ul>
<li>解决方案：设置高度或者父标签设置padding-bottom代替子标签的margin-bottom，或者再放个标签让父标签浮动，子标签设置margin- bottom</li>
</ul>
<p>12.IE6不支持圆角</p>
<ul>
<li>解决方案： IE6不支持CSS3的圆角属性，性价比最高的解决方法就是用图片圆角来替代，或者放弃IE6的圆角。 </li>
</ul>
<p>13.绝对定位元素的1像素间距bug </p>
<blockquote>
<p>当绝对定位元素的父元素高或宽为奇数时，bottom和right会产生错误,唯一的解决办法就是给父元素定义明确的高宽值。</p>
</blockquote>
<p>14.IE6调整窗口大小的Bug </p>
<blockquote>
<p>当把body居中放置，改变IE浏览器大小的时候，任何在body里面的相对定位元素都会固定不动了。解决办法：给body定义position:relative;就行了。</p>
</blockquote>
<p>15.边框点线(IE6)不支持dotted（只是一个像素的时候才出现问题）</p>
<ul>
<li>解决办法：切图片做背景</li>
</ul>
<p>16.H5新标签低版本的浏览器不支持<br>    新的语义标签能够更方便的让搜索引擎爬取网站关键内容，以便SEO优化，然而低版本的ie浏览器并不支持这种新的标签：</p>
<ul>
<li>解决办法：<blockquote>
<p>1.通过<!--[if lt IE 9]>···<![endif]-->条件判断如果是低版本的浏览器使用js创建相应的元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE9]&gt; </span></div><div class="line">&lt;script&gt; </div><div class="line">   (function() &#123;</div><div class="line">     if (! </div><div class="line">     /*@cc_on!@*/</div><div class="line">     0) return;</div><div class="line">     var e = "abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video".split(', ');</div><div class="line">     var i= e.length;</div><div class="line">     while (i--)&#123;</div><div class="line">         document.createElement(e[i])</div><div class="line">     &#125; </div><div class="line">&#125;)() </div><div class="line">&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>2.使用第三方框架，如htmlshim（原理跟上述条件式判断相同）<br>但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局</p>
</blockquote>
<p>17.ul标签内外边距问题</p>
<blockquote>
<p>ul标签在IE6\IE7中，有个默认的外边距，但是在IE8以上及其他浏览器中有个默认的内边距,解决的方案是清除ul的内外边距都为0（margin:0;pandding:0;）。</p>
</blockquote>
<p>18.CSS的hack问题</p>
<ul>
<li>原理<blockquote>
<p>由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!</p>
</blockquote>
</li>
<li>hack分类<blockquote>
<p>CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法和IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。<br>属性前缀法(即类内部Hack)：例如 IE6能识别下划线”<em>“和星号” <em> “，IE7能识别星号” </em> “，但不能识别下划线”</em>“，IE6~IE10都认识”\9”，但firefox前述三个都不能认识。<br>选择器前缀法(即选择器Hack)：例如 IE6能识别<em>html .class{}，IE7能识别</em>+html .class{}或者*:first-child+html .class{}。<br>IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容 <![endif]-->，针对IE6及以下版本： <!--[if lt IE 6]>只在IE6-显示的内容 <![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。<br>CSS hack书写顺序，一般是将适用范围广、被识别能力强的CSS定义在前面。</p>
</blockquote>
</li>
<li>CSS hack方式一：条件注释法<blockquote>
<p>HTML条件注释判断IE<!--[if IE]>这段文字只在ie9以下的浏览器显示<!--[if lt IE 9]>--><br>只在IE8上不生效<!--[if ! IE 8]>这段文字在非IE8浏览器显示<![endif]--><br>非IE浏览器生效<!--[if !IE]>这段文字只在非IE浏览器显示<![endif]--></p>
</blockquote>
</li>
<li>CSS hack方式二：类内属性前缀法<br>属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。<br>IE浏览器各版本 CSS hack 对照表</li>
</ul>
<table>
<thead>
<tr>
<th>hack</th>
<th>写法</th>
<th>实例</th>
<th>IE6(S)</th>
<th>IE6(Q)</th>
<th>IE7(S)</th>
<th>IE7(Q)</th>
<th>IE8(S)</th>
<th>IE8(Q)</th>
<th>IE9(S)</th>
<th>IE9(Q)</th>
<th>IE10(S)</th>
<th>IE10(Q)</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>*color</td>
<td>青色</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>+</td>
<td>+color</td>
<td>绿色</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>-</td>
<td>-color</td>
<td>黄色</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>_</td>
<td>_color</td>
<td>蓝色</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>#</td>
<td>#color</td>
<td>紫色</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>\0</td>
<td>color:red\0</td>
<td>红色</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>\9\0</td>
<td>color:red\9\0</td>
<td>粉色</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>!important</td>
<td>color:blue !important;color:green;</td>
<td>棕色</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>说明：在标准模式中</p>
<ul>
<li>“-″减号是IE6专有的hack</li>
<li>“\9″ IE6/IE7/IE8/IE9/IE10都生效</li>
<li>“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>
<li>“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</li>
</ul>
<ul>
<li>CSS hack方式三：选择器前缀法<blockquote>
<p>选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。<br>目前最常见的是<br><em>html </em>前缀只对IE6生效<br><em>+html </em>+前缀只对IE7生效<br>@media screen\9{…}只对IE6/7生效<br>@media \0screen {body { background: red; }}只对IE8有效<br>@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效<br>@media screen\0 {body { background: green; }} 只对IE8/9/10有效<br>@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效<br>@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效</p>
</blockquote>
</li>
<li>CSS HACK TABLE<br><img src="./images/hack.png" alt="CSS HACK TABLE"></li>
<li>CSS HACK的利与弊<blockquote>
<p>一般情况下，我们尽量避免使用CSS hack，但是有些情况为了顾及用户体验实现向下兼容，不得已才使用hack。比如由于IE8及以下版本不支持CSS3,而我们的项目页面使用了大量CSS3新属性在IE9/Firefox/Chrome下正常渲染，这种情况下如果不使用css3pie或htc或条件注释等方法时,可能就得让IE8-的专属hack出马了。使用hack虽然对页面表现的一致性有好处，但过多的滥用会造成html文档混乱不堪，增加管理和维护的负担。相信只要大家一起努力，少用、慎用hack，未来一定会促使浏览器厂商的标准越来越趋于统一，顺利过渡到标准浏览器的主流时代。抛弃那些陈旧的IE hack，必将减轻我们编码的复杂度，少做无用功。</p>
</blockquote>
</li>
</ul>
<p>19.IE6下图片的下方有空隙</p>
<ul>
<li>解决方法：给img设置display:block;</li>
</ul>
<p>20.在使用绝对定位或者相对定位后，IE中设置z-index失效</p>
<ul>
<li>原因是因为其元素依赖于父元素的z-index，但是父元素默认为0， 子高父低，所以不会改变显示的顺序</li>
</ul>
<p>21.IE6下无法设置1px的行高，原因是由其默认行高引起的</p>
<ul>
<li>解决方案：为其设置overflow:hidden;或者line-height:1px;</li>
</ul>
<p>22.一些JavaScript的兼容问题</p>
<blockquote>
<p>a、标准的事件绑定方法函数为addEventListener，但IE下是attachEvent；<br>b、事件的捕获方式不一致，标准浏览器是由外至内，而IE是由内到外，但是最后的结果是将IE的标准定为标准<br>c、我们常说的事件处理时的event属性，在标准浏览器其是传入的，IE下由window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement<br>d、在低版本的IE中获取的日期处理函数的值不是与1900的差值，但是在高版本的IE中和标准浏览器保持了一致，获取的值也是与1900的差值。<br>比如：var year= new Date().getYear();<br>e、ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject<br>f、IE中不能操作tr的innerHtml<br>g、获得DOM节点的父节点、子节点的方式不同<br>其他浏览器：parentNode  parentNode.childNodes<br>IE：parentElement parentElement.children</p>
</blockquote>
<p>23.window.location.href问题</p>
<blockquote>
<p>说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;<br>Firefox1.5.x下,只能使用window.location. </p>
<ul>
<li>解决方法：使用window.location来代替window.location.href.</li>
</ul>
</blockquote>
<p>24.相同的文字大小在不同浏览器中显示的大小不一致</p>
<blockquote>
<p>说明：同样是font-size:14px的宋体文字，在不同浏览器下占的空间是不一样的，ie下实际占高16px，下留白3px，ff下实际占高17px，上留白1px，下留白3px，opera下就更不一样了。</p>
<ul>
<li>解决方案：给文字设置line-height属性，确保文字占据的高度保持一致。</li>
</ul>
</blockquote>
<p>25.IE6中，上下两个div，上面设置了背景，下面一个没有背景，但在页面中发现下面的div也有了背景，怎么解决这个问题？</p>
<ul>
<li>解决方案：设置zoom:1</li>
</ul>
<p>26.img图片底部留白现象。</p> 
<ul>
<li>解决方案：给img设置display:block</li>
</ul>
<p>27.IE6环境中，如果元素设置了float属性，且没有定义宽度，内部块元素如果定义了height或者zoom:1属性，则这个内部元素就会占满一整行，即使给了宽度？</p>
<ul>
<li>解决方案：给float元素设置宽度</li>
</ul>
<p>28.绝对定位的div下包含相对定位的div，如果给内层相对定位的div高度height具体值，内层相对层将具有100%的width值，外层绝对层将被撑大。</p>
<ul>
<li>解决方案：给内部相对定位的元素设置floa属性</li>
</ul>
<p>29.FF低版本浏览器中，width:100%不会查找到拥有真实宽度的父元素，而是在拥有浮动属性的上级元素就停止向上查找了</p>
<ul>
<li>解决方案：给有浮动的元素添加属性width:100%</li>
</ul>
<p>30.li标签的边距变大</p>
<ul>
<li>解决方案：给ul设置(<code>*</code>号必不可少)<code>*display:inline-block</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/前端常见的兼容性问题及解决方案/" data-id="cj4zksgss000cykf4qcgqm6s5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Node.js知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/Node.js知识点总结/" class="article-date">
  <time datetime="2017-07-11T12:49:59.405Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js-知识点总结"><a href="#Node-js-知识点总结" class="headerlink" title="Node.js 知识点总结"></a>Node.js 知识点总结</h1><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js?"></a>什么是Node.js?</h2><ul>
<li>Node.js就是一个JavaScript的运行平台，形同C#的.NetFramework，或者Java的Java虚拟机，亦或者其它语言的一个运行环境，使JavaScript代码可以跨平台运行。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。</li>
</ul>
<h2 id="Node-js能用来做什么？"><a href="#Node-js能用来做什么？" class="headerlink" title="Node.js能用来做什么？"></a>Node.js能用来做什么？</h2><ul>
<li>Node.js可以用来做后台开发，通过Web服务，给浏览器展示数据，以及接受浏览器端提交过来的数据，根据用户的操作对后台数据库实现增删查改等功能。</li>
</ul>
<h2 id="什么是REPL？"><a href="#什么是REPL？" class="headerlink" title="什么是REPL？"></a>什么是REPL？</h2><ul>
<li>“读取-求值-输出-循环”（英语：Read-Eval-Print Loop，简称REPL），是一个简单的，交互式的编程环境。</li>
</ul>
<h2 id="什么是模块化编程？为什么需要模块化编程？"><a href="#什么是模块化编程？为什么需要模块化编程？" class="headerlink" title="什么是模块化编程？为什么需要模块化编程？"></a>什么是模块化编程？为什么需要模块化编程？</h2><ul>
<li>模块化就是将JS代码按照功能分离，根据需求引入不同的模块文件中；目前常见的模块化规范有CommonJS和AMD规范，CommonJS采用的是“同步加载”，当需要的模块加载完毕后继续执行下面的代码，完全按照自上至下的执行顺序；AMD则是按照“异步加载”，当遇到阻塞事件，依次放入事件队列中，先执行后面的代码再去事件队列执行原本阻塞的代码。这也是为什么浏览器端使用的是按照AMD规范的require.js模块化框架，为防止客户端浏览器因为阻塞事件而假死，直到请求的资源加载完毕后才能继续执行后面的代码。</li>
<li>由于web端越来越庞大，为了高效开发，分工协作，便于后期维护，而且模块化的编程也益于避免变量名的污染。</li>
</ul>
<h3 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h3><ul>
<li>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</li>
</ul>
<h3 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h3><ul>
<li>通过终端命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，app.js就是主模块。<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node app.js</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h3><ul>
<li>我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。<br>1.内置模块</li>
<li>如果传递给require函数的是Node.js内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。</li>
</ul>
<p>2.node_modules目录</p>
<ul>
<li>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。<blockquote>
<p>/home/user/node_modules/foo/bar<br>/home/node_modules/foo/bar<br>/node_modules/foo/bar</p>
</blockquote>
</li>
</ul>
<p>3.NODE_PATH环境变量</p>
<ul>
<li>与PATH环境变量类似，Node.js允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量：<blockquote>
<p>NODE_PATH=/home/user/lib:/home/lib</p>
</blockquote>
</li>
<li>当使用require(‘foo/bar’)的方式加载模块时，则Node.js依次尝试以下路径。<blockquote>
<p>/home/user/lib/foo/bar<br>/home/lib/foo/bar</p>
</blockquote>
</li>
</ul>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul>
<li>NPM是随同Node.js一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：<blockquote>
<p>允许用户从NPM服务器下载别人编写的三方包到本地使用。<br>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote>
</li>
<li>安装第三方包使用方法：<code>npm install *** --save</code>,<em>*</em>表示包名，–save是保存在npm包package.json字段中，表示申明三方包依赖，方便分工协作，代码的打包上传，其他人只需要使用npm install命令批量安装三方包了，更重要的是，当以后node-echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建目录结构。<h3 id="npm一些其它命令"><a href="#npm一些其它命令" class="headerlink" title="npm一些其它命令"></a>npm一些其它命令</h3><blockquote>
<p>NPM提供了很多命令，例如install/publish/uninstall，使用npm help可查看所有命令。<br>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。<br>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。<br>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。<br>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。<br>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。<br>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</version></package></package></package></p>
</blockquote>
</li>
</ul>
<h2 id="Node-js中常用的模块有哪些，分别是什么作用"><a href="#Node-js中常用的模块有哪些，分别是什么作用" class="headerlink" title="Node.js中常用的模块有哪些，分别是什么作用"></a>Node.js中常用的模块有哪些，分别是什么作用</h2><table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">http</td>
<td style="text-align:center">开启一个Web服务，给浏览器提供服务</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">给浏览器发送请求用，还可以传递参数(GET)</td>
</tr>
<tr>
<td style="text-align:center">querystring</td>
<td style="text-align:center">处理浏览器通过GET/POST发送过来的参数</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">查找文件的路径</td>
</tr>
<tr>
<td style="text-align:center">fs</td>
<td style="text-align:center">在服务器端读取文件</td>
</tr>
</tbody>
</table>
<h2 id="用Node-js开启一个Web服务"><a href="#用Node-js开启一个Web服务" class="headerlink" title="用Node.js开启一个Web服务"></a>用Node.js开启一个Web服务</h2><ul>
<li><p>步骤：</p>
<blockquote>
<p>1.导入http模块<br>2.使用http模块对象创建一个server对象<br>3.利用server对象处理浏览器的请求<br>4.开启web监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">//导入http服务模块</span></div><div class="line"><span class="keyword">const</span> server = http.createServer();<span class="comment">//创建一个http服务</span></div><div class="line">server.on(<span class="string">'request'</span>,(req,res)=&gt;&#123;<span class="comment">//当浏览器端请求时需要执行的内容</span></div><div class="line">    <span class="keyword">var</span> urlString = req.url;<span class="comment">//获取浏览器端请求的url</span></div><div class="line">    <span class="keyword">var</span> urlObj =url.parse(urlString,<span class="literal">true</span>);<span class="comment">//使用parse将请求的url转换成对象</span></div><div class="line">    res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf8'</span>);<span class="comment">//设置请求头</span></div><div class="line">    res.end(<span class="string">'Hello World!'</span>);<span class="comment">//给浏览器返回内容</span></div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,(err)=&gt;&#123;<span class="comment">//开启监听服务，指定端口为3000，ip为本地。</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;<span class="comment">//发生错误需要执行</span></div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Start Success!'</span>);<span class="comment">//没有错误执行</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>有时候传输并非一次就结束，可以使用字符串拼接的方式来进行传输</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</div><div class="line"><span class="comment">//2.创建一个服务</span></div><div class="line"><span class="keyword">const</span> server = http.createServer()</div><div class="line"><span class="comment">//3.请求、处理、响应</span></div><div class="line">server.on(<span class="string">'request'</span>,(req,res)=&gt;&#123;</div><div class="line">    <span class="comment">//post获取客户端发送过来的参数，使用事件</span></div><div class="line">    <span class="comment">//这个事件可能会被触发多次，就看你的数据量有多大</span></div><div class="line">    <span class="keyword">let</span> body = <span class="string">''</span></div><div class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</div><div class="line">        <span class="comment">//console.log(chunk.toString())</span></div><div class="line">        body+=chunk <span class="comment">//自动调用chunk.toString()</span></div><div class="line">    &#125;)</div><div class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">        <span class="keyword">const</span> paramsObj = querystring.parse(body)</div><div class="line">        <span class="built_in">console</span>.log(paramsObj)</div><div class="line">    &#125;)</div><div class="line">    res.end(<span class="string">"OK1111"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//4. 开启web服务,监听浏览器请求</span></div><div class="line">server.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start success"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GET和POST请求的处理"><a href="#GET和POST请求的处理" class="headerlink" title="GET和POST请求的处理"></a>GET和POST请求的处理</h3><ul>
<li>获取GET请求内容<blockquote>
<p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能:(示例来自于网络使用ES5不想更改了)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">"redis"</span>);</div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"><span class="keyword">var</span> info = <span class="string">"通过HTTPGet方式成功加入队列"</span>;</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>).query;<span class="comment">//解释url参数部分name=zzl&amp;email=zzl@sina.com</span></div><div class="line">    <span class="keyword">var</span> client = redis.createClient();</div><div class="line">    client.lpush(<span class="string">"topnews"</span>, params.info);</div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="comment">//这里的writeHead形同setHeader</span></div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain;charset=utf-8'</span></div><div class="line">    &#125;);</div><div class="line">    client.lpop(<span class="string">"topnews"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">i, o</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(o);<span class="comment">//回调，所以info可能没法得到o的值，就被res.write输出了</span></div><div class="line">    &#125;)</div><div class="line">    client.quit();</div><div class="line">    res.write(info);</div><div class="line">    res.end();</div><div class="line">&#125;).listen(<span class="number">8000</span>, <span class="string">"127.0.0.1"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8000/'</span>);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="const和let的用法"><a href="#const和let的用法" class="headerlink" title="const和let的用法"></a>const和let的用法</h2><ul>
<li>const和let相当于ES5中var，不过ES6进行了划分，固定的常量使用const的定义，变量使用let，其余部分跟var差不多。</li>
<li>如果你要创建的值，不需要更改就是用常量，可以用const定义，如果你的值后面要改就使用let</li>
</ul>
<h2 id="Node-js中字符串的一些用法"><a href="#Node-js中字符串的一些用法" class="headerlink" title="Node.js中字符串的一些用法"></a>Node.js中字符串的一些用法</h2><ul>
<li>includes：判断某一个字符串中是否包含另外一个字符串，其实作用相当于es5的indexOf</li>
<li>startsWith : 判断字符串是否以什么开头，用于<br>判断协议头 http:// file://</li>
<li>endsWith : 判断字符串是否以什么结尾，常用来判断文件后缀名 .png .jpg .jpeg</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br>为什么叫Arrow Function？因为它的定义用的就是一个箭头：<br><code>x =&gt; x * x</code><br>上面的箭头函数相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(x)=&gt;&#123;<span class="comment">//这行的小括号可以省略</span></div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个参数和一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return,并且如果只有一个参数小括号都可以省略<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> - x * x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><ul>
<li><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，this总是指向词法作用域，也就是外层调用者，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></div><div class="line">        <span class="keyword">return</span> fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
<li><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></div><div class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(<span class="number">2015</span>); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Node-js上文件的操作"><a href="#Node-js上文件的操作" class="headerlink" title="Node.js上文件的操作"></a>Node.js上文件的操作</h2><ul>
<li>由于js原本只是在浏览器上运行的脚本语言，为了保障浏览器用户的安全，js只能用来操作DOM和BOM开放的API，不能对计算机底层进行操作，例如文件的读取修改删除等操作。但是Node.js环境是为了让js能够运行在服务器端，客户端的资源请求避免不了要对文件的相关操作，Node.js提供了一套让js操作文件的内置模块：path和fs，前者是处理文件路径的模块，后者是读取文件的模块，他们两个通常都是配合起来使用。<blockquote>
<p>示例代码，监控一个文件，如果存在就删除，如果不存在就创建（死循环）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> source = path.join(__dirname,<span class="string">'abc/abc.txt'</span>);</div><div class="line">fs.watchFile(sourceDir,(curr,prev)=&gt;&#123;<span class="comment">//监控文件的状态，服务一直保持除非结束</span></div><div class="line">    fs.exists(sourceDir,(exists)=&gt;&#123;<span class="comment">//查看文件是否存在</span></div><div class="line">        <span class="keyword">if</span>(!exists)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"文件不存在，我创建一个好了！"</span>);</div><div class="line">            fs.writeFile(source,<span class="string">"Hello World!"</span>,(err)=&gt;&#123;<span class="comment">//写入一个文件（创建）</span></div><div class="line">                <span class="keyword">if</span>(err)&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"文件创建失败！"</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"现在有这么个文件啦！"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            fs.unlink(source,(err)=&gt;&#123;<span class="comment">//删除文件</span></div><div class="line">                <span class="keyword">if</span>(err)&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"文件安静的躺在你的文件夹中，可惜我删除不了!"</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"unlink不喜欢这个文件，所以让你的电脑与它失去了连接!"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="fs模块的相关用法（链接）"><a href="#fs模块的相关用法（链接）" class="headerlink" title="fs模块的相关用法（链接）"></a>fs模块的相关用法<a href="http://blog.csdn.net/xixi880928/article/details/51828813" target="_blank" rel="external">（链接）</a></h3><p>1.读取文件readFile函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">readFile(filename,[options],callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * [options],可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性</div><div class="line"> * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 2.写文件<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(filename,data,[options],callback);</div><div class="line"><span class="keyword">var</span> w_data = <span class="string">'这是一段通过fs.writeFile函数写入的内容；\r\n'</span>;</div><div class="line"><span class="keyword">var</span> w_data = <span class="keyword">new</span> Buffer(w_data);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * data, 写入的数据，可以字符或一个Buffer对象</div><div class="line"> * [options],flag,mode(权限),encoding</div><div class="line"> * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 3.追加的方式写入文件<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(filename,data,[options],callback);</div><div class="line">fs.appendFile(__dirname + <span class="string">'/test.txt'</span>, <span class="string">'使用fs.appendFile追加文件内容'</span>,(err)=&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"追加失败！"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"追加成功！"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>4.打开文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fs.open(filename, flags, [mode], callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * flags, 操作标识，如"r",读方式打开</div><div class="line"> * [mode],权限，如777，表示任何用户读写可执行</div><div class="line"> * callback 打开文件后回调函数，参数默认第一个err,第二个fd为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄</div><div class="line"> */</div><div class="line"> fs.open(__dirname + <span class="string">'/test.txt'</span>, <span class="string">'r'</span>, <span class="string">'0666'</span>, (err, fd)=&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(fd);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p> 5.读文件，读取打开的文件内容到缓冲区中:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.read(fd, buffer, offset, length, position, callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * fd, 使用fs.open打开成功后返回的文件描述符</div><div class="line"> * buffer, 一个Buffer对象，v8引擎分配的一段内存</div><div class="line"> * offset, 整数，向缓存区中写入时的初始位置，以字节为单位</div><div class="line"> * length, 整数，读取文件的长度</div><div class="line"> * position, 整数，读取文件初始位置；文件大小以字节为单位</div><div class="line"> * callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead实际读取字节数，被读取的缓存区对象</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>6.创建目录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path, [mode], callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * path, 被创建目录的完整路径及目录名；</div><div class="line"> * [mode], 目录权限，默认0777</div><div class="line"> * [callback(err)], 创建完目录回调函数,err错误对象</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 7.读取目录<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path, callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * path, 要读取目录的完整路径及目录名；</div><div class="line"> * [callback(err, files)], 读完目录回调函数；err错误对象，files数组，存放读取到的目录中的所有文件名</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 8.删除目录<br> <code>fs.rmdir(path,callback)</code><br> 9.删除文件<br> <code>fs.unlink(path,callback)</code></p>
<h3 id="大文件的拷贝-了解即可"><a href="#大文件的拷贝-了解即可" class="headerlink" title="大文件的拷贝(了解即可)"></a>大文件的拷贝(了解即可)</h3><ul>
<li>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</div><div class="line">    fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</div><div class="line">    copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line">main(process.argv.slice(<span class="number">2</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Buffer模块"><a href="#Buffer模块" class="headerlink" title="Buffer模块"></a>Buffer模块</h2><ul>
<li>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：<code>var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</code></li>
<li>Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如：<code>bin[0]; // =&gt; 0x68;</code></li>
<li>Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：<code>var str = bin.toString(&#39;utf-8&#39;); // =&gt; &quot;hello&quot;</code></li>
<li><p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer(<span class="string">'hello'</span>, <span class="string">'utf-8'</span>); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节<code>bin[0] = 0x48;</code></p>
</li>
<li><p>而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">bin     bin.slice(<span class="number">2</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</div><div class="line"><span class="keyword">var</span> sub = bin.slice(<span class="number">2</span>);</div><div class="line">sub[<span class="number">0</span>] = <span class="number">0x65</span>;</div><div class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</div><div class="line"><span class="keyword">var</span> dup = <span class="keyword">new</span> Buffer(bin.length);</div><div class="line">bin.copy(dup);</div><div class="line">dup[<span class="number">0</span>] = <span class="number">0x48</span>;</div><div class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></div><div class="line"><span class="built_in">console</span>.log(dup); <span class="comment">// =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
</li>
</ul>
<h2 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h2><ul>
<li>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。</li>
<li><p>我们可以使用.parse方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(<span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span>);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">&#123; protocol: 'http:',</div><div class="line">  auth: 'user:pass',</div><div class="line">  host: 'host.com:8080',</div><div class="line">  port: '8080',</div><div class="line">  hostname: 'host.com',</div><div class="line">  hash: '#hash',</div><div class="line">  search: '?query=string',</div><div class="line">  query: 'query=string',</div><div class="line">  pathname: '/p/a/t/h',</div><div class="line">  path: '/p/a/t/h?query=string',</div><div class="line">  href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
<li><p>传给.parse方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，request.url不包含协议头和域名，但同样可以用.parse方法解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tmp = request.url; <span class="comment">// =&gt; "/foo/bar?a=b"</span></div><div class="line">    url.parse(tmp);</div><div class="line">    <span class="comment">/* =&gt;</span></div><div class="line">    &#123; protocol: null,</div><div class="line">      slashes: null,</div><div class="line">      auth: null,</div><div class="line">      host: null,</div><div class="line">      port: null,</div><div class="line">      hostname: null,</div><div class="line">      hash: null,</div><div class="line">      search: '?a=b',</div><div class="line">      query: 'a=b',</div><div class="line">      pathname: '/foo/bar',</div><div class="line">      path: '/foo/bar?a=b',</div><div class="line">      href: '/foo/bar?a=b' &#125;</div><div class="line">    */</div><div class="line">&#125;).listen(<span class="number">80</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。反过来，format方法允许将一个URL对象转换为URL字符串，示例如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">url.format(&#123;</div><div class="line">    <span class="attr">protocol</span>: <span class="string">'http:'</span>,</div><div class="line">    <span class="attr">host</span>: <span class="string">'www.example.com'</span>,</div><div class="line">    <span class="attr">pathname</span>: <span class="string">'/p/a/t/h'</span>,</div><div class="line">    <span class="attr">search</span>: <span class="string">'query=string'</span></div><div class="line">&#125;);<span class="comment">//'http://www.example.com/p/a/t/h?query=string'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，.resolve方法可以用于拼接URL，示例如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url.resolve(<span class="string">'http://www.example.com/foo/bar'</span>, <span class="string">'../baz'</span>);<span class="comment">//http://www.example.com/baz</span></div></pre></td></tr></table></figure></p>
<h2 id="querystring模块"><a href="#querystring模块" class="headerlink" title="querystring模块"></a>querystring模块</h2><ul>
<li>querystring模块用于实现URL参数字符串与参数对象的互相转换，示例如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">querystring.parse(<span class="string">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge'</span>);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;</div><div class="line">*/</div><div class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: [<span class="string">'qux'</span>, <span class="string">'quux'</span>], <span class="attr">corge</span>: <span class="string">''</span> &#125;);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><ul>
<li>我们在服务器端编程主要用到的模块有Node.js提供的核心模块，以及npm上下载的第三方模块。除此之外我们也可以自定义自己的模块，使之符合MVC的编程思想，把不同的功能的代码划分为不同的模块。<h3 id="如何自定义模块"><a href="#如何自定义模块" class="headerlink" title="如何自定义模块"></a>如何自定义模块</h3></li>
<li>通常在浏览器端的js代码可以通过自执行函数或者符合AMD规范的require.js模块框架来实现模块的划分。在Node.js中，作者是使用同步加载模块的CommonJS来导入导出模块</li>
</ul>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><ul>
<li>在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。</li>
<li>在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。</li>
<li><p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo1 = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</div><div class="line"><span class="keyword">var</span> foo2 = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>);</div><div class="line"><span class="keyword">var</span> foo3 = <span class="built_in">require</span>(<span class="string">'/home/user/foo'</span>);</div><div class="line"><span class="keyword">var</span> foo4 = <span class="built_in">require</span>(<span class="string">'/home/user/foo.js'</span>);</div><div class="line"><span class="comment">// foo1至foo4中保存的是同一个模块的导出对象</span></div></pre></td></tr></table></figure>
</li>
<li><p>另外，可以使用以下方式加载和使用一个JSON文件:<code>var data = require(&#39;./data.json&#39;);</code></p>
</li>
</ul>
<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><ul>
<li>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><ul>
<li>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="服务器端的模板渲染-xtemplate-amp-xtpl模块参考"><a href="#服务器端的模板渲染-xtemplate-amp-xtpl模块参考" class="headerlink" title="服务器端的模板渲染-xtemplate&amp;xtpl模块参考"></a>服务器端的模板渲染-xtemplate&amp;xtpl模块<a href="https://www.npmjs.com/package/xtpl" target="_blank" rel="external">参考</a></h2><ul>
<li>xtemplate和xtpl的作用在于在服务器端生成动态的网页模板<blockquote>
<p>注意点：这俩模板必须结合使用</p>
</blockquote>
</li>
<li>xtemplate就是在网页中写一些类似于模版引擎的语法（在我们网页中进行占位的）,这个就像<code>${lis}</code>符号的作用。注意，我们如果用了xtemplate就要严格按照它的格式来写，xtemplate语法很强大(比如：实现页面之间的集成)，在页面中进行占位，并且通过xtpl读取需要替换的网页，将里面用xtemplate占位的部分，用真实的数据替换掉，并且生成好一个完整的html页面.<a href="https://www.npmjs.com/package/xtpl" target="_blank" rel="external">参考</a></li>
<li>使用步骤：<br>1.安装xtpl&amp;xtemplate包<br><code>npm i xtpl xtemplate --save</code><br>2.现在html中利用xtemplate语法进行占位(不需要在页面中导入xtemplate);<br>3.在开启web服务的js中，使用xtpl，利用真实的数据，替换index.html中的这些占位符，最终得到一个完整的带有数据的html页面,此web服务js中需要依赖这两个模板包模块</li>
<li>示例，简易播放器：<blockquote>
<p>1.在动态html中使用xtemplate占位</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div><div class="line">    &#123;&#123;#each(array)&#125;&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;xindex+1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;this.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"play('&#123;&#123;this.name&#125;&#125;')"</span>&gt;</span>播放<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    &#123;&#123;/each&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>2.在web服务的js中导入相关包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> xtpl = <span class="built_in">require</span>(<span class="string">'xtpl'</span>)</div><div class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</div><div class="line"><span class="keyword">const</span> server = http.createServer()</div><div class="line"><span class="keyword">const</span> musics = <span class="built_in">require</span>(path.join(__dirname,<span class="string">'musics.json'</span>))<span class="comment">//需要的真实数据</span></div></pre></td></tr></table></figure></p>
<p>3.判断浏览器端如果请求的是动态网页，使用xtpl读取网页文件，并用真实数据替换原本用xtemplate占位的部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(req.url.includes(<span class="string">'list.html'</span>))&#123;</div><div class="line">    xtpl.renderFile(path.join(__dirname,<span class="string">'list.html'</span>),&#123;<span class="attr">array</span>:musics&#125;,(err,content)=&gt;&#123;</div><div class="line">        res.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/html;charset=utf-8"</span>)</div><div class="line">        res.end(content)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="使用第三方账号登陆"><a href="#使用第三方账号登陆" class="headerlink" title="使用第三方账号登陆"></a>使用第三方账号登陆</h2><ul>
<li>步骤：<blockquote>
<ul>
<li><p>申请成为开发者<br><br>1、去微博、微信、QQ开发者中心去注册成为他的开发者 <a href="http://open.weibo.com/" target="_blank" rel="external">链接</a><br><br>2、去开放平台的后台，上传某个App的相关信息等待验证</p>
</li>
<li><p>正式接入:<br><br>1、去下载它的sdk，就是一个/多个js文件(有点类似于下载jQuery.js)<br>2、导入到你的项目中，一般都是导入一个js文件，一般都是CDN导入<br>3、调用它里面特定的接口(比如登录)<br> 给接口传递一些必要的参数<br> weiboLogin(‘2257804123’,’afasfaf’)<br> $(“#xxId”)<br>4、等用户同意给我们应用授权授权之后，就可以拿到用户在开放平台(微博，微信)的信息了<br>昵称、头像、好友关系<br>5、把上一步获取到的用户的信息传递给后台，后台得存着(把微博用户的信息和我们自己App的账号平台关联起来)</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Express模块（重点）"><a href="#Express模块（重点）" class="headerlink" title="Express模块（重点）"></a>Express模块（重点）</h2><ul>
<li>基本概念：基于 Node.js 平台对HTTP模块封装的第三方模块，用于快速、开放、极简的 web 开发<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">参考</a><h3 id="基本步骤（开启一个web服务，获取get请求）"><a href="#基本步骤（开启一个web服务，获取get请求）" class="headerlink" title="基本步骤（开启一个web服务，获取get请求）"></a>基本步骤（开启一个web服务，获取get请求）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="comment">//2.创建一个app</span></div><div class="line"><span class="keyword">const</span> app = express() <span class="comment">//app 相当于 server</span></div><div class="line"><span class="comment">//3.请求处理响应</span></div><div class="line">app.get(<span class="string">'/index.html'</span>,(req,res)=&gt;&#123; <span class="comment">// server.on('request')</span></div><div class="line">    <span class="comment">//express中的send就相当于在前面添加了一句话 res.setHeader("Content-Type","text/html;charset=utf8")</span></div><div class="line">    res.send(<span class="string">"&lt;h1&gt;我是好人&lt;/h1&gt;"</span>)<span class="comment">//send只能发送string类型的数据，读取到的文件类可以toString后发送</span></div><div class="line">&#125;)</div><div class="line">app.get(<span class="string">'/login'</span>,(req,res)=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(req.query)</div><div class="line">    res.send(<span class="string">"登录成功"</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//4.启动web服务，开始监听</span></div><div class="line">app.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start ok"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="express接受POST请求"><a href="#express接受POST请求" class="headerlink" title="express接受POST请求"></a>express接受POST请求</h3><ul>
<li>express中集成了body-parser这个第三方包，用来读取客户端发送过来的数据中的body部分<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.导入包</span></div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</div><div class="line"><span class="comment">//2.创建一个app</span></div><div class="line"><span class="keyword">const</span> app = express() <span class="comment">//app ===&gt; server</span></div><div class="line"><span class="comment">// parse application/x-www-form-urlencoded </span></div><div class="line"><span class="comment">// 代表在express中集成body-parser这个第三方包</span></div><div class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</div><div class="line"><span class="comment">//3.请求处理响应</span></div><div class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(req.body)</div><div class="line">    res.send(<span class="string">"post登录成功"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//4.启动web服务，开始监听</span></div><div class="line">app.listen(<span class="number">3000</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start ok"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="express中路由的使用"><a href="#express中路由的使用" class="headerlink" title="express中路由的使用"></a>express中路由的使用</h3><ul>
<li>为了方便处理客户端发送过来的请求，express根据请求的路径制定了一套路由规则，将某一类地址的请求划分到一个单独的路由模块中进行处理，并且将路由中的逻辑部分抽取到另外一个控制器模块中，将所有控制器中的数据库操作封装成一个单独的数据库操作的模块中，这样既有利于代码的复用，也有利于后期维护</li>
<li>使用步骤<br>1.在主模块中导入相应的路由模块：<code>const accountRouter = require(path.join(__dirname,&#39;routers/accountRouter.js&#39;))</code><br>2.设置某个地址的请求由该路由模块处理：<code>app.use(&#39;/account&#39;,accountRouter)</code><br>3.在路由模块中创建一个路由对象：<code>const accountRouter = express.Router()</code><br>4.导入相应的控制器模块：<code>const accountCtrl = require(path.join(__dirname,&#39;../controllers/accountController.js&#39;))</code><br>5.在这个路由对象中设置接受请求的方式以及二级路由地址，将逻辑处理交给另外一个控制器模块处理<br><code>accountRouter.get(&#39;/login&#39;,accountCtrl.getLoginPage)</code>//接受二级路由为login，请求的方式为get，并且将逻辑处理交给accountCtrl.getLoginPage控制器处理<br>6.使用<code>module.exports</code>导出这个路由对象：<code>module.exports = accountRouter</code><br>7.建立一个数据库模块，将需要用到的数据库操作分成不同的方法，用exports或者moudle.exports导出，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>)</div><div class="line"><span class="keyword">const</span> MongoClient = mongodb.MongoClient</div><div class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://localhost:27017/szhmqd06'</span>;</div><div class="line"><span class="keyword">const</span> ObjectId = mongodb.ObjectId</div><div class="line">exports.ObjectId = ObjectId</div><div class="line"></div><div class="line"><span class="keyword">const</span> getDB = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;<span class="comment">//链接数据库</span></div><div class="line">    MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</div><div class="line">        callback(db)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">//暴露出一个通用的查询一个对象的方法</span></div><div class="line">exports.findOne = <span class="function">(<span class="params">collectionName,condition,callback</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">//获取db对象，通过db对象去查询数据库中的一个的操作</span></div><div class="line">    getDB(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</div><div class="line">        <span class="comment">//获取集合</span></div><div class="line">        <span class="keyword">const</span> collection = db.collection(collectionName)</div><div class="line"></div><div class="line">        <span class="comment">//去数据库中查找一个对象</span></div><div class="line">        collection.findOne(condition,(err,doc)=&gt;&#123;</div><div class="line">            <span class="comment">//通过回调函数，将结果传递到控制器中</span></div><div class="line">            callback(doc)</div><div class="line">            db.close()</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>8.在控制器模块中导入数据库模块：<code>const databasemanager = require(path.join(__dirname,&quot;../tools/databasemanager.js&quot;))</code><br>9.在控制器中进行相关的逻辑操作，如某个路由的相关操作，引用数据库模块进行数据库的操作等</p>
<h3 id="express中间件express-session"><a href="#express中间件express-session" class="headerlink" title="express中间件express-session"></a>express中间件express-session</h3><ul>
<li>作用：当客户端访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到客户端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)，方便服务器端校验客户端的相关状态。</li>
<li>express-session的常用参数: <blockquote>
<p>secret:一个String类型的字符串，作为服务器端生成session的签名。<br>name:返回客户端的key的名称，默认为connect.sid,也可以自己设置。<br>resave:(是否允许)当客户端并行发送多个请求时，其中一个请求在另一个请求结束时对session进行修改覆盖并保存。默认为true。但是(后续版本)有可能默认失效，所以最好手动添加。<br>saveUninitialized:初始化session时是否保存到存储。默认为true， 但是(后续版本)有可能默认失效，所以最好手动添加。<br>cookie:设置返回到前端key的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。</p>
</blockquote>
</li>
<li>express-session的一些方法:<blockquote>
<p>Session.destroy():删除session，当检测到客户端关闭时调用。<br>Session.reload():当session有修改时，刷新session。<br>Session.regenerate()：将已有session初始化。<br>Session.save()：保存session。</p>
</blockquote>
</li>
<li>一个DEMO<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</div><div class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</div><div class="line"></div><div class="line">app.use(cookieParser(<span class="string">'sessiontest'</span>));</div><div class="line">app.use(session(&#123;</div><div class="line">    <span class="attr">secret</span>: <span class="string">'sessiontest'</span>,<span class="comment">//与cookieParser中的一致</span></div><div class="line">    resave: <span class="literal">true</span>,</div><div class="line">    <span class="attr">saveUninitialized</span>:<span class="literal">true</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">//修改router/index.js,第一次请求时我们保存一条用户信息。</span></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> user=&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"Chen-xy"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="string">"22"</span>,</div><div class="line">        <span class="attr">address</span>:<span class="string">"bj"</span></div><div class="line">    &#125;</div><div class="line">  req.session.user=user;</div><div class="line">  res.render(<span class="string">'index'</span>, &#123;</div><div class="line">      <span class="attr">title</span>: <span class="string">'the test for nodejs session'</span> ,</div><div class="line">      <span class="attr">name</span>:<span class="string">'sessiontest'</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//修改router/users.js，判断用户是否登陆。</span></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(req.session.user)&#123;</div><div class="line">        <span class="keyword">var</span> user=req.session.user;</div><div class="line">        <span class="keyword">var</span> name=user.name;</div><div class="line">        res.send(<span class="string">'你好'</span>+name+<span class="string">'，欢迎来到我的家园。'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        res.send(<span class="string">'你还没有登录，先登录下再试试！'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图片验证码captchapng模块"><a href="#图片验证码captchapng模块" class="headerlink" title="图片验证码captchapng模块"></a>图片验证码captchapng模块</h2><ul>
<li>用于生成纯数字图片验证码，只支持Base64编码，DEMO：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> captchapng = <span class="built_in">require</span>(<span class="string">'captchapng'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(request.url == <span class="string">'/captcha.png'</span>) &#123;</div><div class="line">        <span class="comment">//一般情况下配合session将随机数保存到某个用于专有的一个空间中，方便做身份验证</span></div><div class="line">        <span class="keyword">var</span> p = <span class="keyword">new</span> captchapng(<span class="number">80</span>,<span class="number">30</span>,<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">9000</span>+<span class="number">1000</span>)); <span class="comment">// width,height,numeric captcha设置图片宽高及随机数</span></div><div class="line">        p.color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// First color: background (red, green, blue, alpha)背景颜色</span></div><div class="line">        p.color(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">255</span>); <span class="comment">// Second color: paint (red, green, blue, alpha)字体颜色</span></div><div class="line">        <span class="keyword">var</span> img = p.getBase64();</div><div class="line">        <span class="keyword">var</span> imgbase64 = <span class="keyword">new</span> Buffer(img,<span class="string">'base64'</span>);</div><div class="line">        response.writeHead(<span class="number">200</span>, &#123;</div><div class="line">            <span class="string">'Content-Type'</span>: <span class="string">'image/png'</span><span class="comment">//设置相应头</span></div><div class="line">        &#125;);</div><div class="line">        response.end(imgbase64);</div><div class="line">    &#125; <span class="keyword">else</span> response.end(<span class="string">''</span>);</div><div class="line">&#125;).listen(<span class="number">8181</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Web server started.\n http:\\\\127.0.0.1:8181\\captcha.png'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mongodb数据库模块"><a href="#mongodb数据库模块" class="headerlink" title="mongodb数据库模块"></a>mongodb数据库模块</h2><ul>
<li><p>连接数据库：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient</div><div class="line">  , assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"><span class="comment">// 设置需要连接的数据的url</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">'mongodb://localhost:27017/myproject'</span>;</div><div class="line"><span class="comment">// 连接数据库，回调中第一个参数为错误信息，第二个为返回的数据库对象</span></div><div class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</div><div class="line">  assert.equal(<span class="literal">null</span>, err);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected correctly to server"</span>);</div><div class="line">  db.close();<span class="comment">//通常情况下，数据库操作一旦结束就必须关闭，解除资源占用，防止数据库连接达到上限</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>增</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> insertDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取要添加的数据库表</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 插入多个，插入一个用insertOne，回调第二个参数为返回的插入的状态</span></div><div class="line">  collection.insertMany([</div><div class="line">    &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</div><div class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">3</span>, result.result.n);</div><div class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the document collection"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>删</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> deleteDocument = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取要删除的数据库表</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 删除一个，多个则为deleteMany，回调第二个参数为返回删除的状态</span></div><div class="line">  collection.deleteOne(&#123; <span class="attr">a</span> : <span class="number">3</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">1</span>, result.result.n);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Removed the document with the field a equal to 3"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>查</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> findDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 设置相应的查找的表格</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 未设置参数则为查询所有，也可以通过正则匹配如在find中设置：`&#123; name : &#123;$regex:'辣'&#125;`则为查找name字段中包含辣的所有条目</span></div><div class="line">  collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">2</span>, docs.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</div><div class="line">    <span class="built_in">console</span>.dir(docs);</div><div class="line">    callback(docs);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> updateDocument = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// Get the documents collection </span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 修改文档中的a=2数据，设置为b=1</span></div><div class="line">  collection.updateOne(&#123; <span class="attr">a</span> : <span class="number">2</span> &#125;</div><div class="line">    , &#123; <span class="attr">$set</span>: &#123; <span class="attr">b</span> : <span class="number">1</span> &#125; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">1</span>, result.result.n);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Updated the document with the field a equal to 2"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>上述增删查改都是单独的方法，使用前请配合连接数据库使用 </strong></p>
<h2 id="all和next的使用"><a href="#all和next的使用" class="headerlink" title="all和next的使用"></a>all和next的使用</h2><ul>
<li>all和next用于路由的权限设置，比如某些需要登录才能查看操作的页面，如果不设置权限就会导致数据的暴露。通常设置在主文件中<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.all(<span class="string">'/*'</span>,(req,res,next)=&gt;&#123;<span class="comment">//匹配到所有的路由</span></div><div class="line">    <span class="keyword">if</span>(req.url.includes(<span class="string">'account'</span>))&#123;</div><div class="line">        next()<span class="comment">//如果访问的是account路由则不做权限限制</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//做权限判断</span></div><div class="line">        <span class="keyword">if</span>(req.session.loginedname != <span class="literal">null</span>)&#123;</div><div class="line">            next()<span class="comment">//如果客户端以及拥有session（说明已经登陆）则不做权限限制</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有登陆则告知用户并跳转到登陆页面</span></div><div class="line">            res.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/html;charset=utf-8"</span>)</div><div class="line">            res.end(<span class="string">"&lt;script&gt;alert('请先登录');location.href='/account/login'&lt;/script&gt;"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2><h3 id="为什么需要加密："><a href="#为什么需要加密：" class="headerlink" title="为什么需要加密："></a>为什么需要加密：</h3><ul>
<li>由于http的传输无论是post或get，都不是绝对安全的，或者说只需要稍微了解HTTP劫持就能破解用户和服务器之间的数据传输，因为前者是将请求的内容明文的形式放入请求体中，后者则是直接明文的暴露在url中，这时候就需要将用户传输的数据进行加密后传输。</li>
</ul>
<h3 id="加密原理："><a href="#加密原理：" class="headerlink" title="加密原理："></a>加密原理：</h3><ul>
<li>MD5消息摘要算法(MD5 Message-Digest Algorithm),是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。经过MD5消息摘要算法得到的内容具有唯一性，好比身份证，且不可逆，于是MD5被广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。</li>
<li>由于MD5加密后的hash值具有唯一性，且不可逆，所以在客户端通过MD5加密后，将密文传输到服务器端保存在数据库中，当用户下次再输入时，通过客户端MD5加密的密文如果跟服务器端数据库匹配的一致，说明用户输入正确。</li>
<li>但是也由于唯一性，导致网路上有大量的MD5库，一些简短的信息和密码可能已经被包含在MD5库中，别人只需要通过撞库就能查询到原来的内容。</li>
</ul>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><p>1.安装MD5：<code>$ npm install md5</code><br>2.导入MD5模块：<code>var md5 = require(&#39;md5&#39;)</code><br>3.加密：<code>md5(message)</code>,message表示需要加密的内容，返回一个加密后的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/Node.js知识点总结/" data-id="cj4zksgrw0004ykf40i7ciriy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/jQuery面试题/" class="article-date">
  <time datetime="2017-07-11T12:49:59.381Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1. 选择题:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>在Jquery中下面哪一个是用来追加到指定元素的末尾(B);</div><div class="line">	A.inserAfter()</div><div class="line">	B.append()</div><div class="line">	C.appendTo()</div><div class="line">	D.After()</div><div class="line">    </div><div class="line"><span class="number">2.</span>jQuery ajax中都包含哪些返回类型？（ABCD）  </div><div class="line">    A. XML</div><div class="line">    B. Html</div><div class="line">    C. jsonp</div><div class="line">    D. json</div><div class="line">    </div><div class="line"><span class="number">3.</span>下列说法不正确的是（D）</div><div class="line">    A. $.ajaxComplete表示ajax请求完成时调用方法  <span class="comment">//正确：请求完成后回调函数 (请求成功或失败之后均调用)。</span></div><div class="line">    B. jsonp的请求只能用get方式                  <span class="comment">//正确：采用script的src属性，只能是get方法</span></div><div class="line">    C. Ajax的请求一般有get post <span class="keyword">delete</span>,put等方式 <span class="comment">//正确：不过一般采用get和post方式</span></div><div class="line">    D. $.post()一般用于获取数据                  <span class="comment">//错误：get方法用于获取数据</span></div><div class="line">    </div><div class="line"><span class="number">4.</span>下面说法不正确的是（A）；</div><div class="line"> 	A. $(<span class="string">":hidden"</span>)选取input标签的type类型是hidden的不可见元素  <span class="comment">//匹配所有不可见元素，或者type为hidden的元素</span></div><div class="line">    B. $(<span class="string">"div&gt;span"</span>)选取div元素下元素名为span的子元素</div><div class="line">    C. $(<span class="string">"div:first"</span>)选取所有div元素中的第一个div元素</div><div class="line">    D. $(<span class="string">"input:gt(1)"</span>)选取索引值大于<span class="number">1</span>的input标签</div></pre></td></tr></table></figure></p>
<p>####1. 怎么理解jQuery？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">答：JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE <span class="number">6.0</span>+， FF1<span class="number">.5</span>+， Safari <span class="number">2.0</span>+， Opera <span class="number">9.0</span>+），jQuery2<span class="number">.0</span>及后续版本将不再支持IE6/<span class="number">7</span>/<span class="number">8</span>浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需要定义id即可。</div><div class="line">jQuery是一个兼容多浏览器的javascript库，核心理念是write less，<span class="keyword">do</span> more(写得更少，做得更多)。jQuery在<span class="number">2006</span>年<span class="number">1</span>月由美国人John Resig在纽约的barcamp发布，吸引了来自世界各地的众多JavaScript高手加入，由Dave Methvin率领团队进行开发。如今，jQuery已经成为最流行的javascript库，在世界前<span class="number">10000</span>个访问最多的网站中，有超过<span class="number">55</span>%在使用jQuery。</div><div class="line">jQuery是免费、开源的，使用MIT许可协议。jQuery的语法设计可以使开发更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。除此以外，jQuery提供API让开发者编写插件。其模块化的使用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。</div><div class="line">jQuery，顾名思义，也就是JavaScript和查询（Query），即是辅助JavaScript开发的库。</div></pre></td></tr></table></figure></p>
<p>####2.Jquery .on这个方法怎么看？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">on()是通过事件委托方式去实现的,对祖元素添加绑定事件，通过事件冒泡的形式，传递给子元素，从而实现触发事件的效果;</div></pre></td></tr></table></figure></p>
<p>####3. 原生JS的window.onload与Jquery的$(document).ready(function () {})，$(function () {})有什么不同？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">答：  </div><div class="line">	<span class="number">1.</span>执行时间 </div><div class="line">		<span class="built_in">window</span>.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </div><div class="line">		$(<span class="built_in">document</span>).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 </div><div class="line">  	<span class="number">2.</span>编写个数不同 </div><div class="line">		<span class="built_in">window</span>.onload不能同时编写多个，如果有多个<span class="built_in">window</span>.onload方法，只会执行一个 </div><div class="line">		$(<span class="built_in">document</span>).ready()可以同时编写多个，并且都可以得到执行  </div><div class="line">	<span class="number">3.</span>简化写法 </div><div class="line">		<span class="built_in">window</span>.onload没有简化写法 </div><div class="line">		$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)可以简写成$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)；</div></pre></td></tr></table></figure></p>
<p>####4. 简述在jQuery中.eq()和.get()的异同？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">答：相同：</div><div class="line">get() ：取得其中一个匹配的元素。数字序号表示取得第几个匹配的元素</div><div class="line">eq()：获取第N个元素，下标都是从<span class="number">0</span>开始， 用法基本相同。</div><div class="line">不同：</div><div class="line">eq返回的是一个jquery对象； 返回的是jQuery对象，就可以继续调用其他方法。</div><div class="line">get返回的是一个html 对象数组；不能调用jQuery的其他方法；</div></pre></td></tr></table></figure></p>
<p>####5.bind(), live(), delegate()的区别<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。</div><div class="line">    live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。</div><div class="line">    delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。</div></pre></td></tr></table></figure></p>
<p>####6.jQuery框架中$.ajax()的常用参数有哪些？写一个post请求并带有发送数据和返回数据的样例;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span>是否异步</div><div class="line">url请求地址</div><div class="line">contentType发送信息至服务器时内容编码类型</div><div class="line">data发送到服务器的数据</div><div class="line">dataType预期服务器返回的数据类型</div><div class="line">type请求类型</div><div class="line">success请求成功回调函数</div><div class="line">error请求失败回调函数</div><div class="line">$.ajax(&#123;</div><div class="line">          <span class="attr">url</span>: <span class="string">"/jquery/test1.txt"</span>,</div><div class="line">          <span class="attr">type</span>: <span class="string">'post'</span>,</div><div class="line">          <span class="attr">data</span>: &#123;</div><div class="line">              <span class="attr">id</span>: <span class="number">1</span></div><div class="line">          &#125;,</div><div class="line">          <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            alert(data);</div><div class="line">         &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>####7. Jquery与jQuery UI 有啥区别？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。</div><div class="line">*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。</div><div class="line">提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</div></pre></td></tr></table></figure></p>
<p>####8. jquery 中如何将数组转化为json字符串，然后再转化回来？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</div><div class="line">    $.fn.stringifyArray = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(array)</div><div class="line">    &#125;</div><div class="line">    $.fn.parseArray = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(array)</div><div class="line">    &#125; </div><div class="line">    然后调用：</div><div class="line">    $(<span class="string">""</span>).stringifyArray(array)</div></pre></td></tr></table></figure></p>
<p>####9.JQuery的源码看过吗？能不能简单概况一下它的实现原理？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">看过,基本实现原理是运用面对对象的原则，将常用的js操作，封装到jQuery函数的原型或原型链中，并对外部暴露出，jQuery和$对象，通过对象使用经过封装处理好的方法;</div></pre></td></tr></table></figure></p>
<p>####10.jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>执行init构造函数自身，其实就是jQuery实例对象，返回<span class="keyword">this</span>是为了实现jQuery的链式操作</div></pre></td></tr></table></figure></p>
<p>####11. jquery中如何将数组转化为json字符串，然后再转化回来？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">自带</div><div class="line">$.parseJSON(<span class="string">'&#123;"name":"John"&#125;'</span>);</div><div class="line">自定义: 转换成字符串</div><div class="line">$.fn.stringify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">$(array).stringify();</div></pre></td></tr></table></figure></p>
<p>####12.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">主要利用了递归的自调用原理，从而将深层的复杂类型数据，再次解析，并返回;</div><div class="line">jQuery.extend([deep], target, object1, [objectN]);</div><div class="line">deep:如果设为<span class="literal">true</span>，则递归合并。</div><div class="line">target:待修改对象。</div><div class="line">object1:待合并到第一个对象的对象。</div><div class="line">objectN:待合并到第一个对象的对象。</div><div class="line"></div><div class="line">递归实践深拷贝</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Copy</span>(<span class="params">obj, n</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> clone = n || &#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">		<span class="keyword">if</span>(clone == obj) &#123;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> obj[k] == <span class="string">'object'</span>) &#123;</div><div class="line">			clone[k] = (<span class="built_in">Array</span>.isArray(obj[k])) ? [] : &#123;&#125;;</div><div class="line">			Copy(obj[k],clone[k]);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		clone[k] = obj[k];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = Copy(obj);</div><div class="line"><span class="built_in">console</span>.log(obj1);</div></pre></td></tr></table></figure></p>
<p>####13.jquery.extend 与 jquery.fn.extend的区别？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jquery.extend用来扩展jQuery对象本身；jquery.fn.extend用来扩展jQuery实例</div></pre></td></tr></table></figure></p>
<p>####14.谈一下Jquery中的bind(),live(),delegate(),on()的区别？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bind(type,[data],fn) 选择器匹配的元素会附加一个事件处理函数，而以后再添加的元素则不会有。为此需要再使用一次 .bind() 才行;</div><div class="line">type: 含有一个或多个事件类型的字符串，由空格分隔多个事件。比如<span class="string">"click"</span>或<span class="string">"submit"</span>，还可以是自定义事件名。</div><div class="line">data:作为event.data属性值传递给事件对象的额外数据对象</div><div class="line">fn:绑定到每个匹配元素的事件上面的处理函数</div><div class="line"></div><div class="line">delegate(selector,[type],[data],fn)  指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。</div><div class="line">selector:选择器字符串，用于过滤器触发事件的元素。</div><div class="line">type:附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</div><div class="line">data:传递到函数的额外数据</div><div class="line">fn:当事件发生时运行的函数</div><div class="line"></div><div class="line">on(events,[selector],[data],fn) 在选择元素上绑定一个或多个事件的事件处理函数。</div><div class="line">events:一个或多个用空格分隔的事件类型和可选的命名空间，如<span class="string">"click"</span>或<span class="string">"keydown.myPlugin"</span> 。</div><div class="line">selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择的&lt; <span class="literal">null</span>或省略，当它到达选定的元素，事件总是触发。</div><div class="line">data:当一个事件被触发时要传递event.data给事件处理函数。</div><div class="line">fn:该事件被触发时执行的函数。 <span class="literal">false</span> 值也可以做一个函数的简写，返回<span class="literal">false</span>。</div><div class="line"></div><div class="line">live(event,data,<span class="function"><span class="keyword">function</span>) 能对一个还没有添加进<span class="title">DOM</span>的元素有效，是由于使用了事件委托：绑定在祖先元素上的事件处理函数可以对在后代上触发的事件作出回应。</span></div><div class="line">    传递给 .<span class="title">live</span>(<span class="params"></span>) 的事件处理函数不会绑定在元素上，而是把他作为一个特殊的事件处理函数，绑定在 <span class="title">DOM</span> 树的根节点上。</div><div class="line"><span class="title">event</span>: 必需。规定附加到元素的一个或多个事件。</div><div class="line"><span class="title">data</span>: 可选。规定传递到该函数的额外数据。</div><div class="line"><span class="title">function</span>: 必需。规定当事件发生时运行的函数。</div></pre></td></tr></table></figure></p>
<p>####15.JQuery一个对象可以同时绑定多个事件，这是如何实现的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind(),live(),delegate(),on()可以同时绑定多个事件，低层实现原理是使用addEventListner与attachEvent兼容处理做事件注册</div></pre></td></tr></table></figure></p>
<p>####16.针对 jQuery 的优化方法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">优先使用ID选择器</div><div class="line">在<span class="class"><span class="keyword">class</span>前使用<span class="title">tag</span>(标签名)</span></div><div class="line">给选择器一个上下文</div><div class="line">慎用 .<span class="title">live</span>()方法（应该说尽量不要使用）</div><div class="line">使用<span class="title">data</span>()方法存储临时变量</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/jQuery面试题/" data-id="cj4zksgs70008ykf4a1jb7jca" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/JavaScript闭包/" class="article-date">
  <time datetime="2017-07-11T12:49:59.347Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h2><ul>
<li>要理解闭包，首先必须理解Javascript特殊的变量作用域。</li>
<li>变量的作用域无非就是两种：全局变量和局部变量。</li>
<li><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　alert(n);</div><div class="line">&#125;</div><div class="line">f1(); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
</li>
<li><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> 　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">alert(n); <span class="comment">// error</span></div></pre></td></tr></table></figure>
</li>
<li><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　n=<span class="number">999</span>;</div><div class="line">&#125;</div><div class="line">f1();</div><div class="line">alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h2><ul>
<li>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</li>
<li><p>那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n); <span class="comment">// 999</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），</p>
</li>
<li>子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</li>
<li>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line"> 　<span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h2><ul>
<li>上一节代码中的f2函数，就是闭包。</li>
<li>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</li>
<li>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</li>
<li>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</li>
</ul>
<h2 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h2><ul>
<li>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</li>
<li><p>怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result=f1();</div><div class="line">result(); <span class="comment">// 999</span></div><div class="line">nAdd();</div><div class="line">result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure>
</li>
<li><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
</li>
<li>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，* 而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</li>
<li>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个</li>
<li>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</li>
</ul>
<h2 id="五、使用闭包的注意点"><a href="#五、使用闭包的注意点" class="headerlink" title="五、使用闭包的注意点"></a>五、使用闭包的注意点</h2><p>1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2.闭包会在父函数外部改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h2 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h2><p>如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;   </div><div class="line"><span class="keyword">var</span> object = &#123;   </div><div class="line">　　<span class="attr">name</span> : <span class="string">"My Object"</span>,   </div><div class="line">　　<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </div><div class="line">　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </div><div class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;   </div><div class="line">　　　&#125;;   </div><div class="line">　　&#125;   </div><div class="line">&#125;;   </div><div class="line">alert(object.getNameFunc()());  <span class="comment">//The Window</span></div><div class="line"><span class="comment">//JavaScript闭包例子</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>)</span></div><div class="line"> &#123;</div><div class="line">  <span class="keyword">var</span> a=<span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>)</span></div><div class="line">  &#123;</div><div class="line">   a++;</div><div class="line">   alert(a);</div><div class="line">  &#125;    </div><div class="line"> &#125;</div><div class="line">innerFun()</div></pre></td></tr></table></figure></p>
<ul>
<li><p>上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的。改成如下,也就是闭包:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">var</span> a=<span class="number">0</span>;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>)</span></div><div class="line"> &#123;</div><div class="line">  a++;</div><div class="line">  alert(a);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> innerFun;  <span class="comment">//注意这里</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=outerFun();</div><div class="line">obj();  <span class="comment">//结果为1</span></div><div class="line">obj();  <span class="comment">//结果为2</span></div><div class="line"><span class="keyword">var</span> obj2=outerFun();</div><div class="line">obj2();  <span class="comment">//结果为1</span></div><div class="line">obj2();  <span class="comment">//结果为2</span></div></pre></td></tr></table></figure>
</li>
<li><p>当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们.</p>
</li>
<li><p>再来看一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">var</span> a =<span class="number">0</span>;</div><div class="line"> alert(a);  </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</div><div class="line">outerFun();</div><div class="line">alert(a);</div></pre></td></tr></table></figure>
</li>
<li><p>结果是 0,4 .  因为在函数内部使用了var关键字 维护a的作用域在outFun()内部.</p>
</li>
<li><p>再看下面的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line"> <span class="comment">//没有var </span></div><div class="line"> a =<span class="number">0</span>;</div><div class="line"> alert(a);  </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</div><div class="line">outerFun();</div><div class="line">alert(a);</div></pre></td></tr></table></figure>
</li>
<li><p>结果为 0,0 真是奇怪,为什么呢?</p>
</li>
<li>作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4;  并改变其值.</li>
<li>如果你对javascript闭包还不是很理解，那么请看下面转载的文章：<a href="http://www.felixwoo.com/archives/247" target="_blank" rel="external">转载</a><br></li>
</ul>
<ul>
<li>闭包官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</li>
<li><p>相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </div><div class="line"> <span class="keyword">var</span> i = <span class="number">0</span>; </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123; alert(++i); &#125; </div><div class="line"> <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = a();</div><div class="line">c();</div></pre></td></tr></table></figure>
</li>
<li><p>这段代码有两个特点：<br>1、函数b嵌套在函数a内部；<br>2、函数a返回函数b。</p>
</li>
<li><p>引用关系如图：<br> <img src="./images/yindao.jpg" alt="引用关系图"></p>
</li>
<li><p>这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，* 就是说，当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</p>
</li>
<li>让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。</li>
</ul>
<h2 id="七、闭包有什么作用？"><a href="#七、闭包有什么作用？" class="headerlink" title="七、闭包有什么作用？"></a>七、闭包有什么作用？</h2><ul>
<li>简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。<br>在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。</li>
<li>那么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍)</li>
</ul>
<h2 id="八、闭包内的微观世界"><a href="#八、闭包内的微观世界" class="headerlink" title="八、闭包内的微观世界"></a>八、闭包内的微观世界</h2><ul>
<li>如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。<br>1.当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。<br>2.当执行函数a的时候，a会进入相应的执行环境(excution context)。<br>3.在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。<br>4.然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。<br>5.下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。<br>6.最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。</li>
<li>到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。</li>
<li>当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：<br><img src="./images/zuoyongyulian.jpg" alt="作用域链"></li>
<li><p>如图所示，当在函数b中访问一个变量的时候，搜索顺序是：<br>1.先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。<br>2.如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。<br>3.如果整个作用域链上都无法找到，则返回undefined。<br>小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123; </div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</div><div class="line"><span class="keyword">return</span> g;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> h = f(<span class="number">1</span>);</div><div class="line">alert(h());</div></pre></td></tr></table></figure>
</li>
<li><p>这段代码中变量h指向了f中的那个匿名函数(由g返回)。<br>1.假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。<br>2.假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。<br>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。<br>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p>
</li>
</ul>
<h2 id="九、闭包的应用场景"><a href="#九、闭包的应用场景" class="headerlink" title="九、闭包的应用场景"></a>九、闭包的应用场景</h2><ul>
<li>保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。<br>1.在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。<br>2.通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）</li>
<li><p>私有属性和方法在Constructor外是无法被访问的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">...</span>) </span>&#123;  </div><div class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;  </div><div class="line"><span class="keyword">var</span> membername = value; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">membername</span>(<span class="params">...</span>) </span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上3点是闭包最基本的应用场景，很多经典案例都源于此。<br>五、Javascript的垃圾回收机制<br>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。</p>
</li>
</ul>
<h2 id="十、结语"><a href="#十、结语" class="headerlink" title="十、结语"></a>十、结语</h2><ul>
<li>理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/JavaScript闭包/" data-id="cj4zksgrv0003ykf4c9lazbgd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/http协议/" class="article-date">
  <time datetime="2017-07-11T12:49:59.334Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="HTTP-1-0介绍"><a href="#HTTP-1-0介绍" class="headerlink" title="HTTP/1.0介绍"></a>HTTP/1.0介绍</h3><p>HTTP 协议是互联网的基础协议，它是基于 TCP/IP 协议(传输层协议)的应用层协议，不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口，是一种请求/响应式的协议，客户端与服务器建立连接后，发送一个请求给服务器，服务器接到请求后，给予相应的响应信息。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>HTTP/1.0 版的主要缺点是：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。<br>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p>
<p>Connection: keep-alive</p>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>
<p>Connection: keep-alive</p>
<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>请求消息结构</p>
<p>由请求行、请求头字段、一个空行和消息主体构成。</p>
<p>请求行:请求消息的第一行就是请求行。它指明使用的请求方法、资源标示符、和 HTTP 版本。如：</p>
<p>GET /demo.htm HTTP/1.1</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>请求方法用来定义操作资源的方式，HTTP/1.1 协议中定义了八种请求方法：</p>
<p>GET：读取资源数据;<br>POST：新建资源数据;<br>PUT：更新资源数据;<br>DELETE：删除资源数据;<br>HEAD：读取资源的元数据;<br>OPTIONS：读取该资源所支持的所有请求方法;<br>TRACE：回显服务器收到的请求，主要用于测试或诊断;<br>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接.</p>
<h3 id="请求头字段"><a href="#请求头字段" class="headerlink" title="请求头字段"></a>请求头字段</h3><p>Cache-Control：客户端希望服务端如何缓存自己的请求数据，如”Cache-Control: no-cache”，”Cache-Control: max-age=0”；<br>Connection：客户端是否希望与服务端之间保持长连接，如”Connection: close”, “Connection: keep-alive”；<br>Date：只有当请求方法为POST或PUT方法时客户端才可能会有些字段；<br>Pragma：包含了客户端一些特殊请求信息，如 “Pragma: no-cache”, 客户端希望代理或应用服务器不应缓存与该请求相关的结果数据；<br>Accept： 表明客户端可接受的请求回应的媒体类型范围列表,如：如 Accept: text/html;<br>Accept-Charset：客户端所能识别的字符集编码格式；<br>Accept-Language：客户端所能识别的语言；<br>Host：客户请求的主机域名或主机IP；<br>User-Agent：表明用户所使用的浏览器标识，主要用于统计的目的；<br>Referer：指明该请求是从哪个页面连接过来的;<br>Accept-Encoding：客户端所能识别的编码压缩格式，如：”Accept-Encoding: gzip, deflate”；<br>If- Modified-Since：该字段与客户端缓存相关，客户端所访问的URL自该指定日期以来在服务端是否被修改过，如果修改过则服务端返回新的修改后 的信息，如果未修改过则服务器返回304表明此请求所指URL未曾修改过；<br>If-None-Match：该字段与客户端缓存相关，客户端发送URL请求的同时发送该字段及标识，如 果服务端的标识与客户端的标识一致，则返回304表明此URL未修改过，如果不一致则服务端返回完整的数据信息;<br>Cookie：为扩展字段，存储于客户端，向同一域名的服务端发送属于该域的cookie；<br>Content-Encoding：客户端所能识别的编码压缩格式，如：Content-Encoding: gzip, deflate；<br>Content-Length：客户端以POST方法上传数据时数据体部分的内容长度，如：Content-Length: 24；<br>Content- Type：客户端发送的数据体的内容类型，如：Content-Type: application/x-www-form-urlencoded为以普通的POST方法发送的数据；</p>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>指示头字段区完成，消息主体开始（如果有消息主体的话）。</p>
<h3 id="消息主体"><a href="#消息主体" class="headerlink" title="消息主体"></a>消息主体</h3><p>消息主体是请求消息的承载数据。比如在提交POST表单，并且表单方法不是GET时，表单数据就是打包在消息主体内的。消息主体是可选的。</p>
<h3 id="响应消息结构"><a href="#响应消息结构" class="headerlink" title="响应消息结构"></a>响应消息结构</h3><p>状态行</p>
<p>由http版本、状态码、状态描述文字构成。如：</p>
<p> HTTP/1.1 200 OK </p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>HTTP 状态码是用以表示网页服务器 HTTP 响应状态的3位数字代码。 所有的状态码的第一个数字代表了响应的五种状态之一:</p>
<p>1xx：代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束；<br>2xx：代表请求已成功被服务器接收、理解、并接受；<br>3xx：代表需要客户端采取进一步的操作才能完成请求。通常，这些v,状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明；<br>4xx：代表了客户端看起来可能发生了错误，妨碍了服务器的处理。<br>5xx：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源 无法完成对请求的处理。</p>
<h3 id="常见状态码有："><a href="#常见状态码有：" class="headerlink" title="常见状态码有："></a>常见状态码有：</h3><p>200: 请求已经成功，请求所希望的响应头或者数据体将随着此响应返回 ;<br>202: 服务器已接受请求，但尚未处理。<br>204: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息;<br>301：永久重定向;<br>302：临时重定向;<br>304: 被请求的资源内容没有发生更改;<br>400：Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求;<br>401 Unauthorized 请求未授权;<br>403 Forbidden 禁止访问;<br>404: Not Found 请求失败，请求所希望得到的资源未被在服务器上发现;<br>408: 请求超时。客户端可以再次提交这一请求而无需任何修改;<br>500: 服务器内部错误，无法处理请求 ;<br>502: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应。<br>503：由于临时的服务器维护或者过载，服务器当前无法处理请求。</p>
<h3 id="响应头字段"><a href="#响应头字段" class="headerlink" title="响应头字段"></a>响应头字段</h3><p>Cache-Control：服务端要求中间代理及客户端如何缓存自己响应的数据，如”Cache-Control: no-cache”，如：”Cache-Control: private”不希望被缓存，”Cache-Control: public” 可以被缓存；<br>Connection：服务端是否希望与客户端之间保持长连接；<br>Date：只有当请求方法为POST或PUT方法时客户端才可能会有些字段；<br>Pragma：包含了服务端一些特殊响应信息，如”Pragma: no-cache”服务端希望代理或客户端不应缓存结果数据；<br>Transfer-Encoding：服务端向客户端传输数据所采用的传输模式(仅在HTTP1.1中出现)；<br>Accept-Ranges：表明服务端接收的数据单位，如：Accept-Ranges: bytes；<br>Location：服务端向客户端返回此信息以使客户端进行重定向；<br>Server：服务器的名称;<br>ETag：服务端返回的响应数据的标识字段，客户端可根据此字段的值向服务器发送某URL是否更新的信息；<br>Content-Encoding：服务端响应数据的编码格式，如：”Content-Encoding: gzip”；<br>Content-Length：服务端返回数据的数据体部分的内容长度，如：”Content-Length: 24”；<br>Content-Type：服务端返回的数据体的内容类型，如：”Content-Type: text/html; charset=utf-8”；<br>Set-Cookie：服务端返回给客户端的cookie数据;</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP1.1 版的最大变化，就是引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p>
<p>Connection: close</p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>HTTP1.1 版还引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。<br>举例来说：客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是：允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h3 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p>
<p>Content-Length: 3495</p>
<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。<br>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。<br>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p>
<p>Transfer-Encoding: chunked</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。<br>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p>
<p>Host: www.example.com</p>
<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”。<br>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。<br>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。<br>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h3 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。<br>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<p>###　数据流</p>
<p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。<br>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/http协议/" data-id="cj4zksgs50007ykf4tx0g12ba" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-angularjs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/angularjs/" class="article-date">
  <time datetime="2017-07-11T12:49:59.320Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h1><h3 id="1-angular在mvvm中的具体划分"><a href="#1-angular在mvvm中的具体划分" class="headerlink" title="1.angular在mvvm中的具体划分"></a>1.angular在mvvm中的具体划分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。</div><div class="line"></div><div class="line">ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；</div><div class="line"></div><div class="line">Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</div><div class="line"></div><div class="line">Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</div></pre></td></tr></table></figure>
<h3 id="2-在使用angularjs项目开发中-你使用过那些第三方的插件"><a href="#2-在使用angularjs项目开发中-你使用过那些第三方的插件" class="headerlink" title="2 在使用angularjs项目开发中 你使用过那些第三方的插件"></a>2 在使用angularjs项目开发中 你使用过那些第三方的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AngularUi  ui-router oclazyload等等</div></pre></td></tr></table></figure>
<p>附上一篇文章仔细去看看 <a href="https://segmentfault.com/a/1190000003858219" target="_blank" rel="external">https://segmentfault.com/a/1190000003858219</a></p>
<h3 id="3-再写controlloer逻辑的时候-你需要注意什么？"><a href="#3-再写controlloer逻辑的时候-你需要注意什么？" class="headerlink" title="3 再写controlloer逻辑的时候 你需要注意什么？"></a>3 再写controlloer逻辑的时候 你需要注意什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.简化代码（这个是所有开发人员都要具备的）</div><div class="line">2.坚决不能操作dom节点 这个时候可能会问 为什么不能啊</div><div class="line">你的回答是：DOM操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular倡导以测试驱动开发，在service或者controller中出现了DOM操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用Angular的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的DOM操作。如果在Angular的代码中还到处充斥着各种DOM操作，那为什么不直接使用jquery去开发呢。</div><div class="line"></div><div class="line">测试驱动开发是什么呢？普及一下：</div><div class="line">测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。</div></pre></td></tr></table></figure>
<h3 id="4-AngularJS的数据双向绑定是怎么实现的？"><a href="#4-AngularJS的数据双向绑定是怎么实现的？" class="headerlink" title="4 AngularJS的数据双向绑定是怎么实现的？"></a>4 AngularJS的数据双向绑定是怎么实现的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">简单说明：</div><div class="line">1、每个双向绑定的元素都有一个watcher</div><div class="line">2、在某些事件发生的时候，调用digest脏数据检测。</div><div class="line">这些事件有：表单元素内容变化、Ajax请求响应、点击按钮执行的函数等。</div><div class="line">3、脏数据检测会检测rootscope下所有被watcher的元素。</div><div class="line">$digest函数就是脏数据监测</div><div class="line"></div><div class="line"></div><div class="line">详细说明：</div><div class="line">$watch和$digest是相辅相成的。两者一起，构成了Angular作用域的核心：数据变化的响应：</div><div class="line">	1.使用$watch，可以在Scope上添加一个监听器。当Scope上发生变更时，监听器会收到提示。给$watch指定如下两个函数，就可以创建一个监听器（$watch会给所有绑定到同一$scope对象的UI元素都会添加一个监控器到$watch数组列表中）：</div><div class="line">          *一个监控函数，用于指定所关注的那部分数据。</div><div class="line">          *一个监听函数，用于在数据变更的时候接受提示，得到调用。</div><div class="line">	2.监听器的监听函数返回我们所关注的那部分数据的变化。</div><div class="line">	3.DOM事件，譬如用户输入文本，点击按钮等。( ng-click )，ajax请求或者 timeout 延迟事件，浏览器Location变更事件 ( $location )，Timer事件( $timeout , $interval )，触发脏检查,即调用$digest函数。</div><div class="line">	4.$digest函数的作用是调用这个监控函数，并且比较它返回的值和上一次返回值的差异。如果不相同，监听器就是脏的，它的监听函数就应当被调用。</div><div class="line">	5.$digest至少运行每个监听器一次了。如果第一次运行完，有监控值发生变更了，标记为dirty，所有监听器再运行第二次。这会一直运行，直到所有监控的值都不再变化，整个局面稳定下来了，这时候才在View渲染该有的数据。</div><div class="line">	6.$digest循环运行10次，Angular就会抛出这个异常，同时停止$digest循环。而10这个次数可以在config里面注入$rootScopeProvider服务并且配置:（如果你想运行15次）</div><div class="line">		*$rootScopeProvider.digestTtl(15);</div><div class="line">	7.也可以使用$apply()来手动触发$digest</div></pre></td></tr></table></figure>
<p>又附上一篇原理性的文章 <a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="external">https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md</a></p>
<h3 id="5-controller之间怎么通讯"><a href="#5-controller之间怎么通讯" class="headerlink" title="5 controller之间怎么通讯"></a>5 controller之间怎么通讯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1、event</div><div class="line">这里可以有两种方式，一种是$scope.$emit，然后通过监听$rootScope的事件获取参数；另一种是$rootScope.$broadcast，通过监听$scope的事件获取参数。</div><div class="line">这两种方法在最新版本的Angular中已经没有性能区别了，主要就是事件发送的方向不同，可以按实际情况选择。</div><div class="line"></div><div class="line">2、service</div><div class="line">可以创建一个专用的事件Service，也可以按照业务逻辑切分，将数据存储在相应的Service中</div><div class="line">3、$rootScope</div><div class="line">这个方法可能会比较dirty一点，胜在方便，也就是把数据存在$rootScope中，这样各个子$scope都可以调用，不过需要注意一下生命周期</div><div class="line"></div><div class="line">4、直接使用$scope.$$nextSibling及类似的属性</div><div class="line">类似的还有$scope.$parent。这个方法的缺点就更多了，官方不推荐使用任何$$开头的属性，既增加了耦合，又需要处理异步的问题，而且scope的顺序也不是固定的。不推荐</div><div class="line"></div><div class="line">另外就是通过本地存储、全局变量或者现代浏览器的postMessage来传递参数了，除非特殊情况，请避免这类方式。</div></pre></td></tr></table></figure>
<h3 id="6-自定义指令的几个参数"><a href="#6-自定义指令的几个参数" class="headerlink" title="6 自定义指令的几个参数"></a>6 自定义指令的几个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">restrict:指令在dom中的声明形式 E（元素）A（属性）C（类名）M（注释）</div><div class="line"></div><div class="line">template：两种形式，一种HTML文本；一个可以接受两个参数的函数，tElemetn和tAttrs，并返回一个代表模板的字符串。模板		字符串必须存在一个根DOM元素</div><div class="line"></div><div class="line">templateUrl:两种形式，一种代表外部HTML文件路径的字符串；一个可以接受两个参数的函数，参数为tElement和tAttrs，并返		  回一个外部HTML文件路径的字符串</div><div class="line"></div><div class="line">compile (对象或函数)：</div><div class="line">	compile 选项可以返回一个对象或函数。如果设置了 compile 函数,说明我们希望在指令和实时数据被		放到DOM中之前进行DOM操作,在这个函数中进行诸如添加和删除节点等DOM操作是安全的。本质上,当我们设置了 link 选	   项,实	际上是创建了一个 postLink() 链接函数,以便 compile() 函数可以定义链接函数。</div><div class="line">然后又是传送门：http://www.cnblogs.com/mliudong/p/4180680.html</div><div class="line"></div><div class="line"> compile和link的区别：</div><div class="line">	  编译的时候，compile转换dom，碰到绑定监听器的地方就先存着，有几个存几个，到最后汇总成一个link函数，一并执行，提升了性能。</div></pre></td></tr></table></figure>
<p>然后又是传送门：<a href="http://www.cnblogs.com/mliudong/p/4180680.html" target="_blank" rel="external">http://www.cnblogs.com/mliudong/p/4180680.html</a></p>
<h3 id="7-angular中的-http"><a href="#7-angular中的-http" class="headerlink" title="7 angular中的$http"></a>7 angular中的$http</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。</div><div class="line">我们可以使用内置的$http服务直接同外部进行通信。$http服务只是简单的封装了浏览器原生的XMLHttpRequest对象。</div><div class="line"></div><div class="line">1、链式调用</div><div class="line"></div><div class="line">$http服务是只能接受一个参数的函数，这个参数是一个对象，包含了用来生成HTTP请求的</div><div class="line">配置内容。这个函数返回一个promise对象，具有success和error两个方法。</div><div class="line">2、返回一个promise对象</div><div class="line"></div><div class="line">3、快捷的get请求</div></pre></td></tr></table></figure>
<p>传送门：[<a href="http://www.2cto.com/kf/201506/405137.html" target="_blank" rel="external">http://www.2cto.com/kf/201506/405137.html</a></p>
<h3 id="8-angular和jquery的区别"><a href="#8-angular和jquery的区别" class="headerlink" title="8 angular和jquery的区别"></a>8 angular和jquery的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">angular是基于数据驱动，所以angular适合做数据操作比较繁琐的项目（这里可以再提一下单页面应用，如果你不会福利又来了 http://www.zhihu.com/question/20792064）</div><div class="line">jquery是基于dom驱动，jquery适合做dom操作多的项目</div></pre></td></tr></table></figure>
<h3 id="9-对angular中的form表单了解多少"><a href="#9-对angular中的form表单了解多少" class="headerlink" title="9 对angular中的form表单了解多少"></a>9 对angular中的form表单了解多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Angular对input元素的type进行了扩展，一共提供了以下10种类型： </div><div class="line">text</div><div class="line">number</div><div class="line">url</div><div class="line">email</div><div class="line">radio</div><div class="line">checkbox</div><div class="line">hidden</div><div class="line">button</div><div class="line">submit</div><div class="line">reset</div><div class="line">Angular为表单内置了4中CSS样式。 </div><div class="line">ng-valid 校验合法状态</div><div class="line">ng-invalid 校验非法状态</div><div class="line">ng-pristine 如果要使用原生的form，需要设置这个值</div><div class="line">ng-dirty     表单处于脏数据状态</div><div class="line">Angular在对表单进行自动校验的时候会校验Model上的属性，如果不设置ng-model，则Angular无法知道myForm.$invalid这个值是否为真。</div><div class="line">校验的一下内容</div><div class="line">required 表示是否输入内容</div><div class="line">ng-maxlength 最大长度</div><div class="line">ng-minlength 最小长度</div></pre></td></tr></table></figure>
<p>例子：传送门[<a href="https://github.com/18500047564/clutter" target="_blank" rel="external">https://github.com/18500047564/clutter</a></p>
<h3 id="10-ng-show-ng-hide-与-ng-if-的区别？"><a href="#10-ng-show-ng-hide-与-ng-if-的区别？" class="headerlink" title="10 ng-show/ng-hide 与 ng-if 的区别？"></a>10 ng-show/ng-hide 与 ng-if 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我们都知道ng-show/ng-hide实际上是通过 display 来进行隐藏和显示的。而ng-if实际上控制dom节点的增删除来实现的。因此如果我们是根据不同的条件来进行dom节点的加载确认的话，那么ng-if的性能好过ng-show.</div></pre></td></tr></table></figure>
<h3 id="解释下什么是-rootScrope-和-scope-的区别？"><a href="#解释下什么是-rootScrope-和-scope-的区别？" class="headerlink" title="解释下什么是 $rootScrope 和$scope 的区别？"></a>解释下什么是 $rootScrope 和$scope 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rootScrope是所有$scope的父对象</div></pre></td></tr></table></figure>
<h3 id="表达式-是如何工作的"><a href="#表达式-是如何工作的" class="headerlink" title="表达式  是如何工作的?"></a>表达式  是如何工作的?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">它依赖于 $interpolation服务，在初始化页面html后，它会找到这些表达式，并且进行标记，于是每遇见一个 &#123;&#123;&#125;&#125; ，则会设置一个 $watch 。而 $interpolation 会返回一个带有上下文参数的函数，最后该函数执行，则算是表达式 $parse 到那个作用域上。</div></pre></td></tr></table></figure>
<h3 id="fliter是什么你了解的有多少？实现一个自定义fliter"><a href="#fliter是什么你了解的有多少？实现一个自定义fliter" class="headerlink" title="fliter是什么你了解的有多少？实现一个自定义fliter"></a>fliter是什么你了解的有多少？实现一个自定义fliter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">ng 内置的 filter 有九种：</div><div class="line"></div><div class="line">date（日期）</div><div class="line"></div><div class="line">currency（货币）</div><div class="line"></div><div class="line">limitTo（限制数组或字符串长度）</div><div class="line"></div><div class="line">orderBy（排序）</div><div class="line"></div><div class="line">lowercase（小写）</div><div class="line"></div><div class="line">uppercase（大写）</div><div class="line"></div><div class="line">number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）</div><div class="line"></div><div class="line">filter（处理一个数组，过滤出含有某个子串的元素）</div><div class="line"></div><div class="line">json（格式化 json 对象）</div><div class="line"></div><div class="line">filter 有两种使用方法，</div><div class="line">一种是直接在页面里：</div><div class="line"></div><div class="line">&lt;p&gt;&#123;&#123;now | date : ‘yyyy-MM-dd’&#125;&#125;&lt;/p&gt;</div><div class="line"></div><div class="line">另一种是在 js 里面用：</div><div class="line"></div><div class="line">$filter(&apos;过滤器名称&apos;)(需要过滤的对象, 参数1, 参数2,...)</div><div class="line"></div><div class="line">$filter(&apos;date&apos;)(now, &apos;yyyy-MM-dd hh:mm:ss’);</div><div class="line"></div><div class="line">自定义一个去重数组的</div><div class="line"></div><div class="line"></div><div class="line">app.filter(&apos;unique&apos;, function()&#123;</div><div class="line">    return function(arr)&#123;</div><div class="line">        var n = [];</div><div class="line">        var obj = &#123;&#125;;</div><div class="line"></div><div class="line">        for(var i = 0;i&lt;arr.length;i++)&#123;</div><div class="line">           if(!obj[arr[i]])&#123;</div><div class="line">            n.push(arr[i])</div><div class="line">            obj[arr[i]] = 1;</div><div class="line">           &#125; </div><div class="line">        &#125;</div><div class="line"></div><div class="line">       return n;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/angularjs/" data-id="cj4zksgs40006ykf4mm6xyl8a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ajax面试题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/ajax面试题总结/" class="article-date">
  <time datetime="2017-07-11T12:49:59.296Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1.缓存问题:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、如何使用缓存？</div><div class="line">可以基于http的头信息控制缓存</div><div class="line">ajax请求对早期的IE浏览器默认就是缓存的，可以通过时间戳防止缓存</div></pre></td></tr></table></figure></p>
<p>###2. AJAX请求数据步骤是什么？传输的数据是用的暗文还是明文？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//创建异步对象</span></div><div class="line"><span class="comment">//get请求</span></div><div class="line"><span class="number">2.</span>xhr.open(<span class="string">'get'</span>,<span class="string">'www.xxx.xxx/xxx?xx=xx&amp;xxx=xx'</span>); <span class="comment">//设置请求行,get方式直接把请求写在链接地址后面即可 : ?xxx=xxxx;</span></div><div class="line"><span class="comment">//post请求</span></div><div class="line"><span class="number">2.</span> xhr.open(<span class="string">'post'</span>,<span class="string">'www.xxx.xx'</span>);</div><div class="line"><span class="number">3.</span> xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);<span class="comment">//post方式需要设置请求头</span></div><div class="line"><span class="number">4.</span> xhr.send(<span class="literal">null</span>);<span class="comment">//请求主体,pos需要把数据以键值对写在主体中 xxx=xxx</span></div><div class="line"><span class="number">5.</span> xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</div><div class="line">      <span class="built_in">JSON</span>.parse(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">ajax的get和post传输数据的方式都是明文;</div></pre></td></tr></table></figure></p>
<p>###3.解释jsonp的原理，以及为什么不是真正的ajax;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jsonp并不是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术</div><div class="line">Ajax直接请求普通文件存在跨域无权限访问的问题，不管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准;</div></pre></td></tr></table></figure></p>
<p>###4. 请尽可能详尽的解释ajax的工作原理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</div><div class="line"></div><div class="line">Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</div><div class="line"></div><div class="line">(<span class="number">1</span>).XMLHTTPRequest对象</div><div class="line">Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</div><div class="line"></div><div class="line">(<span class="number">2</span>).JavaScript</div><div class="line">JavaScript是一在浏览器中大量使用的编程语言。</div><div class="line"></div><div class="line">(<span class="number">3</span>).DOM Document <span class="built_in">Object</span> Model</div><div class="line">DOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，<span class="built_in">document</span>就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document <span class="built_in">Object</span> Model）中，DOM提供了网页中各个对象的读写的支持。</div><div class="line"></div><div class="line">(<span class="number">4</span>).XML</div><div class="line">可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。</div><div class="line"></div><div class="line">(<span class="number">5</span>).综合</div><div class="line">Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。</div><div class="line"></div><div class="line">Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。</div></pre></td></tr></table></figure></p>
<p>###5. 同步和异步的区别?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">同步：阻塞的</div><div class="line">-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭</div><div class="line">=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面</div><div class="line">异步：非阻塞的</div><div class="line">-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃</div><div class="line">=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</div></pre></td></tr></table></figure></p>
<p>###6. 如何解决跨域问题?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</div><div class="line">出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案</div></pre></td></tr></table></figure></p>
<p>###7. 页面编码和被请求的资源编码如果不一致如何处理？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 <span class="built_in">encodeURIComponent</span>函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码</div></pre></td></tr></table></figure></p>
<p>###8. 请解释一下 JavaScript 的同源策略。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2<span class="number">.0</span>，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</div></pre></td></tr></table></figure></p>
<p>###9. GET和POST的区别，何时使用POST？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在<span class="number">2000</span>个字符，有的浏览器是<span class="number">8000</span>个字符</div><div class="line">POST：一般用于修改服务器上的资源，对所发送的信息没有限制</div><div class="line">在以下情况中，请使用 POST 请求：</div><div class="line"><span class="number">1.</span> 无法使用缓存文件（更新服务器上的文件或数据库）</div><div class="line"><span class="number">2.</span> 向服务器发送大量数据（POST 没有数据量限制）</div><div class="line"><span class="number">3.</span> 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</div></pre></td></tr></table></figure></p>
<p>###10. Ajax的最大的特点是什么。ajax的缺点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源； </div><div class="line"><span class="number">10.1</span> ajax的缺点</div><div class="line"> <span class="number">1</span>、ajax不支持浏览器back按钮。</div><div class="line"> <span class="number">2</span>、安全问题 AJAX暴露了与服务器交互的细节。</div><div class="line"> <span class="number">3</span>、对搜索引擎的支持比较弱。</div><div class="line"> <span class="number">4</span>、破坏了程序的异常机制。</div></pre></td></tr></table></figure></p>
<p>###11.http常见的状态码有那些？分别代表是什么意思？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">200</span> OK      <span class="comment">//客户端请求成功</span></div><div class="line"><span class="number">400</span> Bad Request  <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></div><div class="line"><span class="number">403</span> Forbidden  <span class="comment">//服务器收到请求，但是拒绝提供服务</span></div><div class="line"><span class="number">404</span> Not Found  <span class="comment">//请求资源不存在，输入了错误的URL</span></div><div class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span> <span class="comment">//服务器发生不可预期的错误</span></div><div class="line"><span class="number">503</span> Server Unavailable  <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></div></pre></td></tr></table></figure></p>
<p>###12.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">分为<span class="number">4</span>个步骤：</div><div class="line">\<span class="number">1.</span> 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</div><div class="line">\<span class="number">2.</span> 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</div><div class="line">\<span class="number">3.</span> 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 <span class="number">200</span> 的 HTTP 响应状态表示一个正确的响应。</div><div class="line">\<span class="number">4.</span> 此时，Web 服务器提供资源服务，客户端开始下载资源。</div></pre></td></tr></table></figure></p>
<p>###13. ajax请求时，如何解析json数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用<span class="built_in">eval</span>() 或者<span class="built_in">JSON</span>.parse() 鉴于安全性考虑，推荐使用<span class="built_in">JSON</span>.parse()更靠谱，对数据的安全性更好。</div></pre></td></tr></table></figure></p>
<p>###14.请说出三种减低页面加载时间的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、压缩css、js文件</div><div class="line"><span class="number">2</span>、合并js、css文件，减少http请求</div><div class="line"><span class="number">3</span>、外部js、css文件放在最底下</div><div class="line"><span class="number">4</span>、减少dom操作，尽可能用变量替代不必要的dom操作</div></pre></td></tr></table></figure></p>
<p>###15. 为什么利用多个域名来存储网站资源会更有效？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。</div></pre></td></tr></table></figure></p>
<p>###16.JSONP的优缺点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">优点：</div><div class="line">它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；</div><div class="line">能够直接访问响应文本，支持在浏览器与服务器之间双向通信</div><div class="line">缺点：</div><div class="line">JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。</div><div class="line">它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/ajax面试题总结/" data-id="cj4zksgs10005ykf4i5ce93o7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-17.vue框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/17.vue框架/" class="article-date">
  <time datetime="2017-07-11T12:49:59.275Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对框架的理解-“渲染机制”、”数据绑定”、”组件化”、”模块化”这些关键技术点"><a href="#对框架的理解-“渲染机制”、”数据绑定”、”组件化”、”模块化”这些关键技术点" class="headerlink" title="对框架的理解   “渲染机制”、”数据绑定”、”组件化”、”模块化”这些关键技术点"></a>对框架的理解   “渲染机制”、”数据绑定”、”组件化”、”模块化”这些关键技术点</h2><ol>
<li>html页面抽象来看就是就是用来展示页面，呈递信息；所以html可以看成是数据到视图的一种映射；数据变化–&gt;对应的视图变化；</li>
<li>实际上所谓的MVVM框架的关键技术就一个;也就是<strong>数据与视图</strong>的绑定，angular、vue、react等前端框架中的核心思想都有<strong>数据绑定、数据驱动</strong>这个概念；<br> 1.)在Angular/polymer/knockout/vue/avalon 中，这项技术的实现又可以拆分成两个关键点：模板分析和数据监测。<ol>
<li>)而React本质上只是View（视图层），它是Facebook所开发的JavaScript框架，它的唯一目标就是构建高性能的用户接口。开发React就是为了解决其他JavaScript框架都未能解决的一个问题-高效地渲染大型数据集。它采用了<strong>虚拟文档对象模型(DOM)</strong>和<strong>拼接机制</strong>，这样，每一次对网页做了更改后，React就只更新与更改相关的部分，而不需要重新对整个站点进行渲染。</li>
</ol>
</li>
</ol>
<hr>
<h2 id="Vue-js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动和组件系统。"><a href="#Vue-js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动和组件系统。" class="headerlink" title="Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动和组件系统。"></a>Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：<strong>数据驱动</strong>和<strong>组件系统</strong>。</h2><h3 id="数据驱动的实现："><a href="#数据驱动的实现：" class="headerlink" title="数据驱动的实现："></a>数据驱动的实现：</h3><p>官方解释：</p>
<ol>
<li>传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</li>
<li>watcher:每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把<strong>实例属性</strong>记录为依赖，之后当依赖项（实例属性）的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。<br>网上摘抄：</li>
<li>首先，需要利用Object.defineProperty，将要观察的对象，转化成getter/setter，以便拦截 对象赋值与取值操作，称之为Observer；</li>
<li>需要将DOM解析，提取其中的指令与占位符，并赋与不同的操作，称之为Compiler；</li>
<li>需要将Compile的解析结果，与Observer所观察的对象连接起来，建立关系，在Observer观察到对象数据变化时，接收通知，同时更新DOM，称之为Watcher；</li>
<li>最后，需要一个公共入口对象，接收配置，协调上述三者，称为Vue;</li>
</ol>
<h3 id="组件系统："><a href="#组件系统：" class="headerlink" title="组件系统："></a>组件系统：</h3><p>应用类UI可以看作全部是由组件树构成的。<br>注册一个组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    Vue.component(<span class="string">'my-component'</span>, &#123;</div><div class="line">    <span class="comment">// 模板</span></div><div class="line">    template: <span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125; &#123;&#123;privateMsg&#125;&#125;&lt;/div&gt;'</span>,</div><div class="line">    <span class="comment">// 接受参数</span></div><div class="line">    props: &#123;</div><div class="line">        <span class="attr">msg</span>: <span class="built_in">String</span>    </div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 私有数据，需要在函数中返回以避免多个实例共享一个对象</span></div><div class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">privateMsg</span>: <span class="string">'component!'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">&lt;my-component msg=<span class="string">"hello"</span>&gt;&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<h3 id="组件的核心选项"><a href="#组件的核心选项" class="headerlink" title="组件的核心选项"></a>组件的核心选项</h3><p>1 模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。<br>2 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>3 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。<br>4 方法（methods）：对数据的改动操作一般都在组件的方法内进行。<br>5 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。<br>6 私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p>
<p>###vue其他特性：</p>
<ol>
<li>异步批量DOM更新：当大量数据变动时，所有受到影响的watcher会被推送到一个队列中，并且每个watcher只会推进队列一次。这个队列会在进程的下一个 tick异步执行。这个机制可以避免同一个数据多次变动产生的多余DOM操作，也可以保证所有的DOM写操作在一起执行，避免DOM读写切换可能导致的layout。</li>
<li>动画系统：Vue.js提供了简单却强大的动画系统，当一个元素的可见性变化时，用户不仅可以很简单地定义对应的CSS Transition或Animation效果，还可以利用丰富的JavaScript钩子函数进行更底层的动画处理。</li>
<li>可扩展性：除了自定义指令、过滤器和组件，Vue.js还提供了灵活的mixin机制，让用户可以在多个组件中复用共同的特性。</li>
</ol>
<h1 id="构建Vue-WebApp技术栈：vuejs-vuex-vue-router-vue-resource-axios-vux-UI库-预编译-scss-less-stylus-webpack-nodejs"><a href="#构建Vue-WebApp技术栈：vuejs-vuex-vue-router-vue-resource-axios-vux-UI库-预编译-scss-less-stylus-webpack-nodejs" class="headerlink" title="构建Vue WebApp技术栈：vuejs + vuex + vue-router + vue-resource(axios) + vux(UI库) + 预编译(scss/less/stylus) + webpack +_nodejs"></a>构建Vue WebApp技术栈：vuejs + vuex + vue-router + vue-resource(axios) + vux(UI库) + 预编译(scss/less/stylus) + webpack +_nodejs</h1><p>##vue 构建⼤型应⽤ vue 构建⼤型应⽤? ———–使⽤脚⼿架⼯具 </p>
<ol>
<li><p>vue-cli 可以快速地构建项⽬：单⽂件 Vue 组件，热加载，保存时检查代码，单元测试等。 Vue.js 的设计思想是专注与灵活——它只是⼀个界⾯库，不强制使⽤哪个架构。它能很好地与已有项⽬整合，不过对于经验⽋缺的开发者，从头开始构建⼤型应⽤可能是⼀个挑战。 </p>
</li>
<li><p>模块化 对于⼤型项⽬，为了更好地管理代码使⽤模块构建系统⾮常必要。推荐代码使⽤CommonJS 或 ES6 模块，然后使⽤ Webpack 或 Browserify 打包。 Webpack 和 Browserify 不只是模块打包器。两者都提供了源码转换 API，通过它可以⽤其它预处理器转换源码。例如，借助 babel-loader 或 babelify 代码可以使⽤ES2015/2016 语法。 如果你之前没有⽤过它们，</p>
</li>
<li><p>单⽂件组件 在典型的 Vue.js 项⽬中，把界⾯拆分为多个⼩组件，每个组件在同⼀地⽅封装它的 CSS 样式、模板、 JavaScript 定义;使⽤ Webpack 或Browserify 以及合适的源码转换器可以把模板、css、js统统都转换为js</p>
</li>
<li><p>如果你喜欢预处理器，甚⾄可以这么做： vueify 构建这些单⽂件 Vue 组件。推荐使⽤ Webpack，因为它的加载器 API 提供更好的⽂件依赖追踪/缓存以及⼀些 Browserify 没有的转换功能。 最快的构建⽅式是使⽤官⽅出品的脚⼿架⼯具 </p>
<ol>
<li>vue-cli。你也可以在 GitHub 上找到⼀些构建⽰例</li>
<li>Webpack + vue-loader</li>
<li>Browserify + vueify</li>
</ol>
</li>
<li><p>路由 对于单页应⽤，推荐使⽤官⽅库; vue-router。详细请查看它的⽂档。 如果你只需要⾮常简单的路由逻辑，可以这么做:监听 hashchange 事件并使⽤动态组件 利⽤这种机制也可以⾮常容易地配合其它路由库，如 Page.js 或 Director</p>
</li>
<li><p>与服务器通信 Vue 实例的原始数据 $data 能直接⽤ JSON.stringify() 序列化。社区贡献了⼀个插件<br> vue-resource，提供⼀种容易的⽅式与 RESTful APIs 配合。也可以使⽤任何⾃⼰喜欢的 Ajax 库，如 $.ajax 或<br> SuperAgent。Vue.js 也能很好地与⽆后端服务配合，如 Firebase 和 Parse</p>
</li>
<li><p>状态管理 在⼤型应⽤中，状态管理常常变得复杂，因为状态分散在许多组件内。常常忽略Vue.js 应⽤的来源是原⽣的数据对象—— Vue 实例代理访问它。因此，如果⼀个状态要被多个实例共享，应避免复制它</p>
</li>
</ol>
<h2 id="vue-对⽐其它框架"><a href="#vue-对⽐其它框架" class="headerlink" title="vue  对⽐其它框架"></a>vue  对⽐其它框架</h2><ol>
<li><p>Angular 选择 Vue ⽽不选择 Angular;有下⾯⼏个原因，当然不是对每个⼈都适合：<br> 1.在 API 与设计两⽅⾯上 Vue.js 都⽐ Angular 简单得多，因此你可以快速地掌握它的全部特性并投⼊开发。<br>  Vue.js 是⼀个更加灵活开放的解决⽅案。它允许你以希望的⽅式组织应⽤程序，⽽不是任何时候都必须遵循 Angular 制定的规则。它仅仅是⼀个视图层，所以你可以将它嵌⼊⼀个现有页⾯⽽不⼀定要做成⼀个庞⼤的单页应⽤。在配合其他库⽅⾯它给了你更⼤的的空间，但相应，你也需要做更多的架构决策。例如，Vue.js 核⼼默认不包含路由和 Ajax 功能，并且通常假定你在应⽤中使⽤了⼀个模块构建系统。这可能是最重要的区别。 </p>
<ol>
<li>Angular 使⽤双向绑定，Vue 也⽀持双向绑定，不过默认为单向绑定，数据从⽗组件单向传给⼦组件。在⼤型应⽤中使⽤单向绑定让数据流易于理解。在 Vue.js 中指令和组件分得更清晰。指令只封装 DOM 操作，⽽组件代表⼀个⾃给⾃⾜的独⽴单元 —— 有⾃⼰的视图和数据逻辑。在 Angular 中两者有不少相混的地⽅。 </li>
<li><p>Vue.js 有更好的性能，并且⾮常⾮常容易优化，因为它不使⽤脏检查。 Angular，当 watcher 越来越多时会变得越来越慢，因为作⽤域内的每⼀次变化，所有 watcher 都要重新计算。并且，如果⼀些 watcher 触发另⼀个更新，脏检查循环（digest cycle）可能要运⾏多次。 Angular ⽤户常常要使⽤深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有⼤量 watcher 的作⽤域。Vue.js 则根本没有这个问题，因为它使⽤基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独⽴地触发，除⾮它们之间有明确的依赖关系。唯⼀需要做的优化是在 v-for 上使⽤ track-by。 有意思的是，Angular 2 和 Vue ⽤相似的设计解决了⼀些 Angular 1 中存在的问题</p>
</li>
<li><p>React React.js 和 Vue.js 确实有⼀些相似 —— 它们都提供数据驱动、可组合搭建的视图组件。当然它们也有许多不同。 ⾸先，内部实现本质上不同。React 的渲染建⽴在 Virtual DOM 上——⼀种在内存中描述 DOM 树状态的数据结构。当状态发⽣变化时，React 重新渲染 Virtual DOM，⽐较计算之后给真实 DOM 打补丁。 Virtual DOM 提供了⼀个函数式的⽅法描述视图，这真的很棒。因为它不使⽤数据观察机制，每次更新都会重新渲染整个应⽤，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应⽤的可能性。 Vue.js 不使⽤ Virtual DOM ⽽是使⽤真实 DOM 作为模板，数据绑定到真实节点。Vue.js 的应⽤环境必须提供 DOM。但是，相对于常见的误解——Virtual DOM 让React ⽐其它的都快， Vue.js 实际上性能⽐ React 好，⽽且⼏乎不⽤⼿⼯优化。⽽React，为了最优化的渲染需要处处实现 shouldComponentUpdate 或使⽤不可变数据结构。<br>在 API ⽅⾯，React（或 JSX）的⼀个问题是，渲染函数常常包含⼤量的逻辑，最终看着更像是程序⽚断（实际上就是）⽽不是界⾯的视觉呈现。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我⼀样兼顾设计和开发的⼈来说，模板能让我们更好地在视觉上思考设计和 CSS。JSX 和 JavaScript 逻辑的混合⼲扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加⼊⼀个轻量级的 DSL (指令系统)，换来⼀个依旧直观的模板，且能将逻辑封装进指令和过滤器中。React ⽐其它的都快， Vue.js 实际上性能⽐ React 好，⽽且⼏乎不⽤⼿⼯优化。⽽React，为了最优化的渲染需要处处实现 shouldComponentUpdate 或使⽤不可变数据结构。 在 API ⽅⾯，React（或 JSX）的⼀个问题是，渲染函数常常包含⼤量的逻辑，最终看着更像是程序⽚断（实际上就是）⽽不是界⾯的视觉呈现。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我⼀样兼顾设计和开发的⼈来说，模板能让我们更好地在视觉上思考设计和 CSS。JSX 和 JavaScript 逻辑的混合⼲扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加⼊⼀个轻量级的 DSL (指令系统)，换来⼀个依旧直观的模板，且能将逻辑封装进指令和过滤器中。 React 的另⼀个问题是：由于 DOM 更新完全交给 Virtual DOM 管理，当想要⾃⼰控制DOM 时就有点棘⼿了（虽然理论上可以做到，但是这样做就本质上违背了 React 的设计思想）。如果应⽤需要特别的⾃定义 DOM 操作，特别是复杂时间控制的动画，这个限制就很讨厌。在这⽅⾯，Vue.js 更灵活，<br>再多说⼏句： React 团队雄⼼勃勃，计划让 React 成为通⽤平台的 UI 开发⼯具，⽽ Vue 专注于为 Web<br>提供实⽤的解决⽅案。 React，由于它的函数式特质，可以很好地使⽤函数式编程模式。但是对于初级开发者和初学者这也导致较⼤的学习难度。Vue<br>更易学习并能快速投⼊开发。对于⼤型应⽤，React 社区已经创造了⼤量的状态管理⽅案，例如 Flux/Redux。Vue 本⾝不解决这个问题（React 内核也是），但是可以轻松地修改状态管理模式，实现⼀个类似的架构。我已经看到有⽤户以 Vue 使⽤ Redux。Optimizely的⼯程师也以 Vue 使⽤ NuclearJS (他们的 Flux 实现)<br>。 React 的开发趋势是将所有东西都放在 JavaScript 中，包括 CSS。已经有许多CSS-in-JS ⽅案，但是所有的⽅案多多少少都有它的问题。⽽且更重要的是，这么做脱离了标准的 CSS 开发经验，并且很难和 CSS 社区的已有⼯作配合。Vue的<br>单⽂件组件 在把 CSS 封装到组件模块的同时仍然允许你使⽤你喜欢的预处理器</p>
</li>
<li><p>Ember Ember 是⼀个全能框架。它提供⼤量的约定，⼀旦你熟悉了它们，开发会很⾼效。不过，这也意味着学习曲线较⾼，⽽且不灵活。在框架和库（加上⼀系列松散耦合的⼯具）之间权衡选择。后者更⾃由，但是也要求你做更多的架构决定。也就是说，最好⽐较 Vue.js 内核和 Ember<br>的模板与数据模型层： Vue 在普通 JavaScript 对象上建⽴响应，提供⾃动化的计算属性。在 Ember 中需要将所有东西放在 Ember<br>对象内，并且⼿⼯为计算属性声明依赖。Vue 的模板语法可以⽤全功能的 JavaScript 表达式，⽽ Handlebars 的语法和帮<br>助函数语法相⽐之下⾮常受限。 在性能上，Vue 甩开 Ember ⼏条街，即使是 Ember 2.0 最新的 Glimmer 引擎。Vue ⾃动批量更新，在性能⽐较关键时 Ember 要⼿⼯管理循环</p>
</li>
</ol>
</li>
</ol>
<h3 id="vuejs的几大难点："><a href="#vuejs的几大难点：" class="headerlink" title="vuejs的几大难点："></a>vuejs的几大难点：</h3><ol>
<li><p>vue-router –用于实现前端路由,根据url不同请求不同的页面显示(SPA)；类似于angular的$routerProvider</p>
</li>
<li><p>组件间通信:  </p>
<ol>
<li>小型应用：<ol>
<li>父子组件间通信：父传子–&gt; props;子传父—&gt; 子组件发射事件：vm.$emit(‘event’,args), 父组件接收事件：v-on:event;</li>
<li>官方没有提供兄组件之间的有效直接通信方式：可以使用父组件作为中转，解决</li>
</ol>
</li>
<li>中型应用：<ol>
<li>新建一个全局的Vue实例专门用于通信；Vue_State = new Vue();</li>
<li>在需要主动发送状态第组件中：通过这个Vue_State实例调用$emit(event,args)发送事件,在需要接收状态的地方使用$on(event,function(args){})来接收事件</li>
</ol>
</li>
<li><p>大型应用：<br> 1.使用官方推荐第三方插件：vuex来构建一个状态仓库：</p>
<p>  vuex  — 各个组件数据的共享</p>
<pre><code>1. props传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。而且也会导致代码难以维护

2. 解决方法：采用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

3. 每一个 Vuex 应用的核心就是 store（仓库）。&quot;store&quot; 基本上就是一个容器，它包含着应用中大部分的状态(state)。

4. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

5. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化。
</code></pre></li>
</ol>
</li>
</ol>
<hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">vuex的使用示例：</div><div class="line">//vuex/modules/user.js</div><div class="line">import api from '../../fetch/api'</div><div class="line">import * as types from '../types'</div><div class="line"></div><div class="line">const state = &#123;</div><div class="line">    // 用户登录状态</div><div class="line">    loginStatus: JSON.parse(localStorage.getItem('loginStatus')) || false,</div><div class="line">&#125;</div><div class="line"></div><div class="line">const actions = &#123;</div><div class="line">    /**</div><div class="line">     * 用户登录</div><div class="line">     */</div><div class="line">    setUserInfo(&#123; commit &#125;, res) &#123;</div><div class="line">        localStorage.setItem('loginStatus', true)</div><div class="line">        commit(types.SET_LOGIN_STATUS, true)</div><div class="line">    &#125;,</div><div class="line">    /**</div><div class="line">     * 退出登录</div><div class="line">     */</div><div class="line">    setSignOut(&#123; commit &#125;) &#123;</div><div class="line">        localStorage.removeItem('loginStatus')</div><div class="line">        commit(types.SET_LOGIN_STATUS, false)</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">const getters = &#123;</div><div class="line">    loginStatus: state =&gt; state.loginStatus</div><div class="line">&#125;</div><div class="line"></div><div class="line">const mutations = &#123;</div><div class="line">    [types.SET_LOGIN_STATUS](state, status) &#123;</div><div class="line">        state.loginStatus = status</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    state,</div><div class="line">    actions,</div><div class="line">    getters,</div><div class="line">    mutations</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//User.vue</div><div class="line">&lt;template&gt;</div><div class="line">    &lt;div class="user"&gt;</div><div class="line">        &lt;div v-if="!loginStatus"&gt;</div><div class="line">            ...</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div v-else&gt;    </div><div class="line">            ...        </div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">import &#123; mapGetters &#125; from 'vuex'</div><div class="line">export default &#123;</div><div class="line">    computed: &#123;</div><div class="line">        ...mapGetters([</div><div class="line">            'loginStatus'</div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<ol>
<li><p>自定义事件</p>
</li>
<li><p>动态组件: 通过is属性来切换使用不同的组件</p>
</li>
<li><p>组件合并时stor内容分发</p>
</li>
<li><p>vue-resource(axios)<br> 1.发送ajax请求的第三方插件，类似于angular的$http服务；采用promise结构；</p>
</li>
<li><p>webpack ————-&gt; nb的自动化构建工具；<br> Webpack是一个开源的前端模块构建工具，它提供了强大的loader API来定义对不同文件格式的预处理逻辑，这是.vue后缀单文件组件形式的基础。所以在此基础上，Vue官方开发的vue-loader允许将模板、样式、逻辑三要素整合在同一个文件中，以.vue文件后缀形成单文件组件格式，方便项目架构和开发引用。</p>
</li>
</ol>
<p>##Vue面试题 </p>
<ol>
<li>vue中的MVVM模式<br> 即Model-View-ViewModel。  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。 </li>
<li>v-show指令与v-if的区别  条件渲染指令，<br> 与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style.display = ‘none’ ;v-show的初始渲染消耗高，v-if的频繁切换消耗高；</li>
<li>如何让css只在当前组件中起作用  在每一个vue组件中都可以定义各自的css，js，如果希望组件内写的css只对当前组件起作用，只需要在style中写入scoped，即： <style scoped></style> </li>
<li>组件keep-alive  在vue-router写着keep-alive，keep-alive的含义：<br> 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令  <component :is="curremtView" keep-alive=""></component> </li>
<li>Vuejs组件<br> vuejs构建组件使用<br> //声明创建组件：<br> Vue.component(‘componentName’,{ /<em>component</em>/ })；<br> 这里注意一点，组件要先注册再使用<br> Vue.component(‘mine’,{template:’#mineTpl’,props:[‘name’,’title’,’city’,’content’]});<br> //在实例上注册组件<br> var  v = new Vue({<pre><code>    el: &apos;#vueInstance&apos;,
    data: {
        name: &apos;zhang&apos;,
        title: &apos;this is title&apos;,
        city: &apos;Beijing&apos;,
        content: &apos;these are some desc about Blog&apos;
    }
});  
</code></pre></li>
<li><p>路由嵌套<br> 路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转;router-view本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到:var App = Vue.extend({ root }); router.start(App,’#app’); 这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app匹配的元素上。</p>
</li>
<li><p>指令ref的使用  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用ref指令，去给这个元素注册一个索引，方便通过所属实例的$refs访问这个元素。</p>
</li>
<li><p>vuejs中使用事件名  在vuejs中，我们经常要绑定一些事件，有时候给DOM元素绑定，有时候给组件绑定。绑定事件在HTML中用v-on:click=”event”,这时event的名字不要出现大写，因为在1.x中不区分大小写，所以如果我们在HTML写v-on:click=”myEvent”而在js中写myEvent就出错误，所以在vuejs的1.x绑定事件时候，要尽量避免使用大写字母。在2.0中没有该限制！ </p>
</li>
<li><p>Vue.js是什么?<br>  Vue.js（是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。  Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件 </p>
</li>
<li><p>VueJS 特性：<br>I: MVVM模式（数据变量（model）发生改变 视图（view）也改变， 视图（view）改变，数据变量（model）也发生改变）  使用MVVM模式有几大好处：    1. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。    </p>
<ol>
<li>可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。    </li>
<li>独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。    4. 可测试性。可以针对ViewModel来对界面(View)进行测试<br>II: 组件化<br>III 指令系统<br>IIII: vue2.0开始支持虚拟dom  vue1.0是操作的是真的dom元素而不是虚拟的 虚拟dom:可以提升页面的刷新速度虚拟DOM有利也有弊。  A：大小 - 其中之一就是更多的功能意味着代码包中更多行的代码。幸运的是，Vue.js 2.0 依旧比 较小（当前版本 21.4kb），并  且也正在删除很多东西。  B: 内存 -同样，虚拟DOM需要将现有的DOM拷贝后保存在内存中，这是一个在DOM更新速度和内存使用中的权衡。  C: 并不适用所有情况 -如果虚拟DOM可以一次性进行批量的修改是非常好的。但是如果是单独的、稀少的更新呢？这样的任何  DOM更新都将会使虚拟DOM带来无意义的预计算</li>
</ol>
</li>
<li><p>Vue.js特点?  </p>
<ol>
<li>简洁：页面由HTML模板+Json数据+Vue实例组成 </li>
<li>数据驱动：自动计算属性和追踪依赖的模板表达式 </li>
<li>组件化：用可复用、解耦的组件来构造页面 </li>
<li>轻量：代码量小，不依赖其他库 </li>
<li>快速：精确有效批量DOM更新  </li>
<li>模板友好：可通过npm，bower等多种方式安装，很容易融入  </li>
</ol>
</li>
<li><p>Vue.js 和 AngularJS 之间的区别是什么? </p>
<p>下面是一些选择 Vue 而不是 Angular 的可能原因；  Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织你的应用程序，而不是任何时候都必须遵循 Angular 制定的规则。它仅仅是一个视图层，所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在结合其他库方面它给了你更大的的空间，<br>但相应，你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 ajax 功能，并且通常假定你在用应用中使用了一个外部的模块构建系统。这可能是最重要的区别<br>在 API 和内部设计方面，Vue.js 比 Angular 简单得多, 因此你可以快速地掌握它的全部特性并投入开发。<br>Vue.js 拥有更好的性能，因为它不使用脏检查。当 watcher 越来越多时, Angular 会变得越来越慢，因为作用域内的每一次数据变更，所有的 watcher 都需要被重新求值。Vue 则根本没有这个问题，因为它采用的是基于依赖追踪的观察系统，所以所有的数据变更触发都是独立的，除非它们之间有明确的依赖关系。<br>Vue.js 中指令和组件的概念区分得更为清晰。指令只负责封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 它拥有自己的视图和数据逻辑。在 Angular 中它们两者间有不少概念上的混淆</p>
<p>13.Vue.js 和 React.js 有什么区别?  React.js 和 Vue.js 确实有一些相似——它们都提供数据驱动、可组合搭建的视图组件。然而，它们的内部实现是完全不同的。React 是基于 Virtual DOM——一种在内存中描述 DOM 树状态的数据结构。React 中的数据通常被看作是不可变的，而 DOM 操作则是通过 Virtual DOM 的 diff 来计算的。与之相比，Vue.js 中的数据默认是可变的，而数据的变更会直接出发对应的 DOM 更新。相比于 Virtual DOM，Vue.js 使用实际的 DOM 作为模板，并且保持对真实节点的引用来进行数据绑定。  Virtual DOM 提供了一个函数式的描述视图的方法，这很 cool。因为它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图通与数据的同步。它也开辟了 JavaScript 同构应用的可能性</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/17.vue框架/" data-id="cj4zksgrs0002ykf49czl5gqs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/11/前端一些常见面试问题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/前端常用插件/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/前端常见的兼容性问题及解决方案/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/Node.js知识点总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/jQuery面试题/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
