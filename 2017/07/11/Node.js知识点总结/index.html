<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Node.js 知识点总结什么是Node.js? Node.js就是一个JavaScript的运行平台，形同C#的.NetFramework，或者Java的Java虚拟机，亦或者其它语言的一个运行环境，使JavaScript代码可以跨平台运行。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/07/11/Node.js知识点总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Node.js 知识点总结什么是Node.js? Node.js就是一个JavaScript的运行平台，形同C#的.NetFramework，或者Java的Java虚拟机，亦或者其它语言的一个运行环境，使JavaScript代码可以跨平台运行。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据">
<meta property="og:updated_time" content="2017-07-11T11:26:18.028Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Node.js 知识点总结什么是Node.js? Node.js就是一个JavaScript的运行平台，形同C#的.NetFramework，或者Java的Java虚拟机，亦或者其它语言的一个运行环境，使JavaScript代码可以跨平台运行。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Node.js知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/Node.js知识点总结/" class="article-date">
  <time datetime="2017-07-11T12:49:59.405Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js-知识点总结"><a href="#Node-js-知识点总结" class="headerlink" title="Node.js 知识点总结"></a>Node.js 知识点总结</h1><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js?"></a>什么是Node.js?</h2><ul>
<li>Node.js就是一个JavaScript的运行平台，形同C#的.NetFramework，或者Java的Java虚拟机，亦或者其它语言的一个运行环境，使JavaScript代码可以跨平台运行。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。</li>
</ul>
<h2 id="Node-js能用来做什么？"><a href="#Node-js能用来做什么？" class="headerlink" title="Node.js能用来做什么？"></a>Node.js能用来做什么？</h2><ul>
<li>Node.js可以用来做后台开发，通过Web服务，给浏览器展示数据，以及接受浏览器端提交过来的数据，根据用户的操作对后台数据库实现增删查改等功能。</li>
</ul>
<h2 id="什么是REPL？"><a href="#什么是REPL？" class="headerlink" title="什么是REPL？"></a>什么是REPL？</h2><ul>
<li>“读取-求值-输出-循环”（英语：Read-Eval-Print Loop，简称REPL），是一个简单的，交互式的编程环境。</li>
</ul>
<h2 id="什么是模块化编程？为什么需要模块化编程？"><a href="#什么是模块化编程？为什么需要模块化编程？" class="headerlink" title="什么是模块化编程？为什么需要模块化编程？"></a>什么是模块化编程？为什么需要模块化编程？</h2><ul>
<li>模块化就是将JS代码按照功能分离，根据需求引入不同的模块文件中；目前常见的模块化规范有CommonJS和AMD规范，CommonJS采用的是“同步加载”，当需要的模块加载完毕后继续执行下面的代码，完全按照自上至下的执行顺序；AMD则是按照“异步加载”，当遇到阻塞事件，依次放入事件队列中，先执行后面的代码再去事件队列执行原本阻塞的代码。这也是为什么浏览器端使用的是按照AMD规范的require.js模块化框架，为防止客户端浏览器因为阻塞事件而假死，直到请求的资源加载完毕后才能继续执行后面的代码。</li>
<li>由于web端越来越庞大，为了高效开发，分工协作，便于后期维护，而且模块化的编程也益于避免变量名的污染。</li>
</ul>
<h3 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h3><ul>
<li>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</li>
</ul>
<h3 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h3><ul>
<li>通过终端命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，app.js就是主模块。<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node app.js</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h3><ul>
<li>我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。<br>1.内置模块</li>
<li>如果传递给require函数的是Node.js内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。</li>
</ul>
<p>2.node_modules目录</p>
<ul>
<li>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。<blockquote>
<p>/home/user/node_modules/foo/bar<br>/home/node_modules/foo/bar<br>/node_modules/foo/bar</p>
</blockquote>
</li>
</ul>
<p>3.NODE_PATH环境变量</p>
<ul>
<li>与PATH环境变量类似，Node.js允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量：<blockquote>
<p>NODE_PATH=/home/user/lib:/home/lib</p>
</blockquote>
</li>
<li>当使用require(‘foo/bar’)的方式加载模块时，则Node.js依次尝试以下路径。<blockquote>
<p>/home/user/lib/foo/bar<br>/home/lib/foo/bar</p>
</blockquote>
</li>
</ul>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><ul>
<li>NPM是随同Node.js一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：<blockquote>
<p>允许用户从NPM服务器下载别人编写的三方包到本地使用。<br>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote>
</li>
<li>安装第三方包使用方法：<code>npm install *** --save</code>,<em>*</em>表示包名，–save是保存在npm包package.json字段中，表示申明三方包依赖，方便分工协作，代码的打包上传，其他人只需要使用npm install命令批量安装三方包了，更重要的是，当以后node-echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建目录结构。<h3 id="npm一些其它命令"><a href="#npm一些其它命令" class="headerlink" title="npm一些其它命令"></a>npm一些其它命令</h3><blockquote>
<p>NPM提供了很多命令，例如install/publish/uninstall，使用npm help可查看所有命令。<br>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。<br>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。<br>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。<br>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。<br>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。<br>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</version></package></package></package></p>
</blockquote>
</li>
</ul>
<h2 id="Node-js中常用的模块有哪些，分别是什么作用"><a href="#Node-js中常用的模块有哪些，分别是什么作用" class="headerlink" title="Node.js中常用的模块有哪些，分别是什么作用"></a>Node.js中常用的模块有哪些，分别是什么作用</h2><table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">http</td>
<td style="text-align:center">开启一个Web服务，给浏览器提供服务</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">给浏览器发送请求用，还可以传递参数(GET)</td>
</tr>
<tr>
<td style="text-align:center">querystring</td>
<td style="text-align:center">处理浏览器通过GET/POST发送过来的参数</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">查找文件的路径</td>
</tr>
<tr>
<td style="text-align:center">fs</td>
<td style="text-align:center">在服务器端读取文件</td>
</tr>
</tbody>
</table>
<h2 id="用Node-js开启一个Web服务"><a href="#用Node-js开启一个Web服务" class="headerlink" title="用Node.js开启一个Web服务"></a>用Node.js开启一个Web服务</h2><ul>
<li><p>步骤：</p>
<blockquote>
<p>1.导入http模块<br>2.使用http模块对象创建一个server对象<br>3.利用server对象处理浏览器的请求<br>4.开启web监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">//导入http服务模块</span></div><div class="line"><span class="keyword">const</span> server = http.createServer();<span class="comment">//创建一个http服务</span></div><div class="line">server.on(<span class="string">'request'</span>,(req,res)=&gt;&#123;<span class="comment">//当浏览器端请求时需要执行的内容</span></div><div class="line">    <span class="keyword">var</span> urlString = req.url;<span class="comment">//获取浏览器端请求的url</span></div><div class="line">    <span class="keyword">var</span> urlObj =url.parse(urlString,<span class="literal">true</span>);<span class="comment">//使用parse将请求的url转换成对象</span></div><div class="line">    res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf8'</span>);<span class="comment">//设置请求头</span></div><div class="line">    res.end(<span class="string">'Hello World!'</span>);<span class="comment">//给浏览器返回内容</span></div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,(err)=&gt;&#123;<span class="comment">//开启监听服务，指定端口为3000，ip为本地。</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;<span class="comment">//发生错误需要执行</span></div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Start Success!'</span>);<span class="comment">//没有错误执行</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>有时候传输并非一次就结束，可以使用字符串拼接的方式来进行传输</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</div><div class="line"><span class="comment">//2.创建一个服务</span></div><div class="line"><span class="keyword">const</span> server = http.createServer()</div><div class="line"><span class="comment">//3.请求、处理、响应</span></div><div class="line">server.on(<span class="string">'request'</span>,(req,res)=&gt;&#123;</div><div class="line">    <span class="comment">//post获取客户端发送过来的参数，使用事件</span></div><div class="line">    <span class="comment">//这个事件可能会被触发多次，就看你的数据量有多大</span></div><div class="line">    <span class="keyword">let</span> body = <span class="string">''</span></div><div class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</div><div class="line">        <span class="comment">//console.log(chunk.toString())</span></div><div class="line">        body+=chunk <span class="comment">//自动调用chunk.toString()</span></div><div class="line">    &#125;)</div><div class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</div><div class="line">        <span class="keyword">const</span> paramsObj = querystring.parse(body)</div><div class="line">        <span class="built_in">console</span>.log(paramsObj)</div><div class="line">    &#125;)</div><div class="line">    res.end(<span class="string">"OK1111"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//4. 开启web服务,监听浏览器请求</span></div><div class="line">server.listen(<span class="number">3000</span>,<span class="string">"127.0.0.1"</span>,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start success"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GET和POST请求的处理"><a href="#GET和POST请求的处理" class="headerlink" title="GET和POST请求的处理"></a>GET和POST请求的处理</h3><ul>
<li>获取GET请求内容<blockquote>
<p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能:(示例来自于网络使用ES5不想更改了)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">"redis"</span>);</div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"><span class="keyword">var</span> info = <span class="string">"通过HTTPGet方式成功加入队列"</span>;</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>).query;<span class="comment">//解释url参数部分name=zzl&amp;email=zzl@sina.com</span></div><div class="line">    <span class="keyword">var</span> client = redis.createClient();</div><div class="line">    client.lpush(<span class="string">"topnews"</span>, params.info);</div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="comment">//这里的writeHead形同setHeader</span></div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain;charset=utf-8'</span></div><div class="line">    &#125;);</div><div class="line">    client.lpop(<span class="string">"topnews"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">i, o</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(o);<span class="comment">//回调，所以info可能没法得到o的值，就被res.write输出了</span></div><div class="line">    &#125;)</div><div class="line">    client.quit();</div><div class="line">    res.write(info);</div><div class="line">    res.end();</div><div class="line">&#125;).listen(<span class="number">8000</span>, <span class="string">"127.0.0.1"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8000/'</span>);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="const和let的用法"><a href="#const和let的用法" class="headerlink" title="const和let的用法"></a>const和let的用法</h2><ul>
<li>const和let相当于ES5中var，不过ES6进行了划分，固定的常量使用const的定义，变量使用let，其余部分跟var差不多。</li>
<li>如果你要创建的值，不需要更改就是用常量，可以用const定义，如果你的值后面要改就使用let</li>
</ul>
<h2 id="Node-js中字符串的一些用法"><a href="#Node-js中字符串的一些用法" class="headerlink" title="Node.js中字符串的一些用法"></a>Node.js中字符串的一些用法</h2><ul>
<li>includes：判断某一个字符串中是否包含另外一个字符串，其实作用相当于es5的indexOf</li>
<li>startsWith : 判断字符串是否以什么开头，用于<br>判断协议头 http:// file://</li>
<li>endsWith : 判断字符串是否以什么结尾，常用来判断文件后缀名 .png .jpg .jpeg</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br>为什么叫Arrow Function？因为它的定义用的就是一个箭头：<br><code>x =&gt; x * x</code><br>上面的箭头函数相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(x)=&gt;&#123;<span class="comment">//这行的小括号可以省略</span></div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个参数和一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return,并且如果只有一个参数小括号都可以省略<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> - x * x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><ul>
<li><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，this总是指向词法作用域，也就是外层调用者，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></div><div class="line">        <span class="keyword">return</span> fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
<li><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></div><div class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(<span class="number">2015</span>); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Node-js上文件的操作"><a href="#Node-js上文件的操作" class="headerlink" title="Node.js上文件的操作"></a>Node.js上文件的操作</h2><ul>
<li>由于js原本只是在浏览器上运行的脚本语言，为了保障浏览器用户的安全，js只能用来操作DOM和BOM开放的API，不能对计算机底层进行操作，例如文件的读取修改删除等操作。但是Node.js环境是为了让js能够运行在服务器端，客户端的资源请求避免不了要对文件的相关操作，Node.js提供了一套让js操作文件的内置模块：path和fs，前者是处理文件路径的模块，后者是读取文件的模块，他们两个通常都是配合起来使用。<blockquote>
<p>示例代码，监控一个文件，如果存在就删除，如果不存在就创建（死循环）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> source = path.join(__dirname,<span class="string">'abc/abc.txt'</span>);</div><div class="line">fs.watchFile(sourceDir,(curr,prev)=&gt;&#123;<span class="comment">//监控文件的状态，服务一直保持除非结束</span></div><div class="line">    fs.exists(sourceDir,(exists)=&gt;&#123;<span class="comment">//查看文件是否存在</span></div><div class="line">        <span class="keyword">if</span>(!exists)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"文件不存在，我创建一个好了！"</span>);</div><div class="line">            fs.writeFile(source,<span class="string">"Hello World!"</span>,(err)=&gt;&#123;<span class="comment">//写入一个文件（创建）</span></div><div class="line">                <span class="keyword">if</span>(err)&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"文件创建失败！"</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"现在有这么个文件啦！"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            fs.unlink(source,(err)=&gt;&#123;<span class="comment">//删除文件</span></div><div class="line">                <span class="keyword">if</span>(err)&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"文件安静的躺在你的文件夹中，可惜我删除不了!"</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"unlink不喜欢这个文件，所以让你的电脑与它失去了连接!"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="fs模块的相关用法（链接）"><a href="#fs模块的相关用法（链接）" class="headerlink" title="fs模块的相关用法（链接）"></a>fs模块的相关用法<a href="http://blog.csdn.net/xixi880928/article/details/51828813" target="_blank" rel="external">（链接）</a></h3><p>1.读取文件readFile函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">readFile(filename,[options],callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * [options],可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性</div><div class="line"> * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 2.写文件<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(filename,data,[options],callback);</div><div class="line"><span class="keyword">var</span> w_data = <span class="string">'这是一段通过fs.writeFile函数写入的内容；\r\n'</span>;</div><div class="line"><span class="keyword">var</span> w_data = <span class="keyword">new</span> Buffer(w_data);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * data, 写入的数据，可以字符或一个Buffer对象</div><div class="line"> * [options],flag,mode(权限),encoding</div><div class="line"> * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 3.追加的方式写入文件<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(filename,data,[options],callback);</div><div class="line">fs.appendFile(__dirname + <span class="string">'/test.txt'</span>, <span class="string">'使用fs.appendFile追加文件内容'</span>,(err)=&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"追加失败！"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"追加成功！"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>4.打开文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fs.open(filename, flags, [mode], callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * filename, 必选参数，文件名</div><div class="line"> * flags, 操作标识，如"r",读方式打开</div><div class="line"> * [mode],权限，如777，表示任何用户读写可执行</div><div class="line"> * callback 打开文件后回调函数，参数默认第一个err,第二个fd为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄</div><div class="line"> */</div><div class="line"> fs.open(__dirname + <span class="string">'/test.txt'</span>, <span class="string">'r'</span>, <span class="string">'0666'</span>, (err, fd)=&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(fd);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p> 5.读文件，读取打开的文件内容到缓冲区中:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.read(fd, buffer, offset, length, position, callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * fd, 使用fs.open打开成功后返回的文件描述符</div><div class="line"> * buffer, 一个Buffer对象，v8引擎分配的一段内存</div><div class="line"> * offset, 整数，向缓存区中写入时的初始位置，以字节为单位</div><div class="line"> * length, 整数，读取文件的长度</div><div class="line"> * position, 整数，读取文件初始位置；文件大小以字节为单位</div><div class="line"> * callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead实际读取字节数，被读取的缓存区对象</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>6.创建目录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path, [mode], callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * path, 被创建目录的完整路径及目录名；</div><div class="line"> * [mode], 目录权限，默认0777</div><div class="line"> * [callback(err)], 创建完目录回调函数,err错误对象</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 7.读取目录<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path, callback);</div><div class="line"><span class="comment">/**</span></div><div class="line"> * path, 要读取目录的完整路径及目录名；</div><div class="line"> * [callback(err, files)], 读完目录回调函数；err错误对象，files数组，存放读取到的目录中的所有文件名</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p> 8.删除目录<br> <code>fs.rmdir(path,callback)</code><br> 9.删除文件<br> <code>fs.unlink(path,callback)</code></p>
<h3 id="大文件的拷贝-了解即可"><a href="#大文件的拷贝-了解即可" class="headerlink" title="大文件的拷贝(了解即可)"></a>大文件的拷贝(了解即可)</h3><ul>
<li>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</div><div class="line">    fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</div><div class="line">    copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line">main(process.argv.slice(<span class="number">2</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Buffer模块"><a href="#Buffer模块" class="headerlink" title="Buffer模块"></a>Buffer模块</h2><ul>
<li>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：<code>var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</code></li>
<li>Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如：<code>bin[0]; // =&gt; 0x68;</code></li>
<li>Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：<code>var str = bin.toString(&#39;utf-8&#39;); // =&gt; &quot;hello&quot;</code></li>
<li><p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer(<span class="string">'hello'</span>, <span class="string">'utf-8'</span>); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节<code>bin[0] = 0x48;</code></p>
</li>
<li><p>而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">bin     bin.slice(<span class="number">2</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</div><div class="line"><span class="keyword">var</span> sub = bin.slice(<span class="number">2</span>);</div><div class="line">sub[<span class="number">0</span>] = <span class="number">0x65</span>;</div><div class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</div><div class="line"><span class="keyword">var</span> dup = <span class="keyword">new</span> Buffer(bin.length);</div><div class="line">bin.copy(dup);</div><div class="line">dup[<span class="number">0</span>] = <span class="number">0x48</span>;</div><div class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></div><div class="line"><span class="built_in">console</span>.log(dup); <span class="comment">// =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
</li>
</ul>
<h2 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h2><ul>
<li>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。</li>
<li><p>我们可以使用.parse方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(<span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span>);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">&#123; protocol: 'http:',</div><div class="line">  auth: 'user:pass',</div><div class="line">  host: 'host.com:8080',</div><div class="line">  port: '8080',</div><div class="line">  hostname: 'host.com',</div><div class="line">  hash: '#hash',</div><div class="line">  search: '?query=string',</div><div class="line">  query: 'query=string',</div><div class="line">  pathname: '/p/a/t/h',</div><div class="line">  path: '/p/a/t/h?query=string',</div><div class="line">  href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
<li><p>传给.parse方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，request.url不包含协议头和域名，但同样可以用.parse方法解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tmp = request.url; <span class="comment">// =&gt; "/foo/bar?a=b"</span></div><div class="line">    url.parse(tmp);</div><div class="line">    <span class="comment">/* =&gt;</span></div><div class="line">    &#123; protocol: null,</div><div class="line">      slashes: null,</div><div class="line">      auth: null,</div><div class="line">      host: null,</div><div class="line">      port: null,</div><div class="line">      hostname: null,</div><div class="line">      hash: null,</div><div class="line">      search: '?a=b',</div><div class="line">      query: 'a=b',</div><div class="line">      pathname: '/foo/bar',</div><div class="line">      path: '/foo/bar?a=b',</div><div class="line">      href: '/foo/bar?a=b' &#125;</div><div class="line">    */</div><div class="line">&#125;).listen(<span class="number">80</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。反过来，format方法允许将一个URL对象转换为URL字符串，示例如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">url.format(&#123;</div><div class="line">    <span class="attr">protocol</span>: <span class="string">'http:'</span>,</div><div class="line">    <span class="attr">host</span>: <span class="string">'www.example.com'</span>,</div><div class="line">    <span class="attr">pathname</span>: <span class="string">'/p/a/t/h'</span>,</div><div class="line">    <span class="attr">search</span>: <span class="string">'query=string'</span></div><div class="line">&#125;);<span class="comment">//'http://www.example.com/p/a/t/h?query=string'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，.resolve方法可以用于拼接URL，示例如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url.resolve(<span class="string">'http://www.example.com/foo/bar'</span>, <span class="string">'../baz'</span>);<span class="comment">//http://www.example.com/baz</span></div></pre></td></tr></table></figure></p>
<h2 id="querystring模块"><a href="#querystring模块" class="headerlink" title="querystring模块"></a>querystring模块</h2><ul>
<li>querystring模块用于实现URL参数字符串与参数对象的互相转换，示例如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">querystring.parse(<span class="string">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge'</span>);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;</div><div class="line">*/</div><div class="line">querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: [<span class="string">'qux'</span>, <span class="string">'quux'</span>], <span class="attr">corge</span>: <span class="string">''</span> &#125;);</div><div class="line"><span class="comment">/* =&gt;</span></div><div class="line">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><ul>
<li>我们在服务器端编程主要用到的模块有Node.js提供的核心模块，以及npm上下载的第三方模块。除此之外我们也可以自定义自己的模块，使之符合MVC的编程思想，把不同的功能的代码划分为不同的模块。<h3 id="如何自定义模块"><a href="#如何自定义模块" class="headerlink" title="如何自定义模块"></a>如何自定义模块</h3></li>
<li>通常在浏览器端的js代码可以通过自执行函数或者符合AMD规范的require.js模块框架来实现模块的划分。在Node.js中，作者是使用同步加载模块的CommonJS来导入导出模块</li>
</ul>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><ul>
<li>在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。</li>
<li>在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。</li>
<li><p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo1 = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</div><div class="line"><span class="keyword">var</span> foo2 = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>);</div><div class="line"><span class="keyword">var</span> foo3 = <span class="built_in">require</span>(<span class="string">'/home/user/foo'</span>);</div><div class="line"><span class="keyword">var</span> foo4 = <span class="built_in">require</span>(<span class="string">'/home/user/foo.js'</span>);</div><div class="line"><span class="comment">// foo1至foo4中保存的是同一个模块的导出对象</span></div></pre></td></tr></table></figure>
</li>
<li><p>另外，可以使用以下方式加载和使用一个JSON文件:<code>var data = require(&#39;./data.json&#39;);</code></p>
</li>
</ul>
<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><ul>
<li>exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个公有方法:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><ul>
<li>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="服务器端的模板渲染-xtemplate-amp-xtpl模块参考"><a href="#服务器端的模板渲染-xtemplate-amp-xtpl模块参考" class="headerlink" title="服务器端的模板渲染-xtemplate&amp;xtpl模块参考"></a>服务器端的模板渲染-xtemplate&amp;xtpl模块<a href="https://www.npmjs.com/package/xtpl" target="_blank" rel="external">参考</a></h2><ul>
<li>xtemplate和xtpl的作用在于在服务器端生成动态的网页模板<blockquote>
<p>注意点：这俩模板必须结合使用</p>
</blockquote>
</li>
<li>xtemplate就是在网页中写一些类似于模版引擎的语法（在我们网页中进行占位的）,这个就像<code>${lis}</code>符号的作用。注意，我们如果用了xtemplate就要严格按照它的格式来写，xtemplate语法很强大(比如：实现页面之间的集成)，在页面中进行占位，并且通过xtpl读取需要替换的网页，将里面用xtemplate占位的部分，用真实的数据替换掉，并且生成好一个完整的html页面.<a href="https://www.npmjs.com/package/xtpl" target="_blank" rel="external">参考</a></li>
<li>使用步骤：<br>1.安装xtpl&amp;xtemplate包<br><code>npm i xtpl xtemplate --save</code><br>2.现在html中利用xtemplate语法进行占位(不需要在页面中导入xtemplate);<br>3.在开启web服务的js中，使用xtpl，利用真实的数据，替换index.html中的这些占位符，最终得到一个完整的带有数据的html页面,此web服务js中需要依赖这两个模板包模块</li>
<li>示例，简易播放器：<blockquote>
<p>1.在动态html中使用xtemplate占位</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div><div class="line">    &#123;&#123;#each(array)&#125;&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;xindex+1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;this.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"play('&#123;&#123;this.name&#125;&#125;')"</span>&gt;</span>播放<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    &#123;&#123;/each&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>2.在web服务的js中导入相关包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> xtpl = <span class="built_in">require</span>(<span class="string">'xtpl'</span>)</div><div class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</div><div class="line"><span class="keyword">const</span> server = http.createServer()</div><div class="line"><span class="keyword">const</span> musics = <span class="built_in">require</span>(path.join(__dirname,<span class="string">'musics.json'</span>))<span class="comment">//需要的真实数据</span></div></pre></td></tr></table></figure></p>
<p>3.判断浏览器端如果请求的是动态网页，使用xtpl读取网页文件，并用真实数据替换原本用xtemplate占位的部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(req.url.includes(<span class="string">'list.html'</span>))&#123;</div><div class="line">    xtpl.renderFile(path.join(__dirname,<span class="string">'list.html'</span>),&#123;<span class="attr">array</span>:musics&#125;,(err,content)=&gt;&#123;</div><div class="line">        res.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/html;charset=utf-8"</span>)</div><div class="line">        res.end(content)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="使用第三方账号登陆"><a href="#使用第三方账号登陆" class="headerlink" title="使用第三方账号登陆"></a>使用第三方账号登陆</h2><ul>
<li>步骤：<blockquote>
<ul>
<li><p>申请成为开发者<br><br>1、去微博、微信、QQ开发者中心去注册成为他的开发者 <a href="http://open.weibo.com/" target="_blank" rel="external">链接</a><br><br>2、去开放平台的后台，上传某个App的相关信息等待验证</p>
</li>
<li><p>正式接入:<br><br>1、去下载它的sdk，就是一个/多个js文件(有点类似于下载jQuery.js)<br>2、导入到你的项目中，一般都是导入一个js文件，一般都是CDN导入<br>3、调用它里面特定的接口(比如登录)<br> 给接口传递一些必要的参数<br> weiboLogin(‘2257804123’,’afasfaf’)<br> $(“#xxId”)<br>4、等用户同意给我们应用授权授权之后，就可以拿到用户在开放平台(微博，微信)的信息了<br>昵称、头像、好友关系<br>5、把上一步获取到的用户的信息传递给后台，后台得存着(把微博用户的信息和我们自己App的账号平台关联起来)</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Express模块（重点）"><a href="#Express模块（重点）" class="headerlink" title="Express模块（重点）"></a>Express模块（重点）</h2><ul>
<li>基本概念：基于 Node.js 平台对HTTP模块封装的第三方模块，用于快速、开放、极简的 web 开发<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">参考</a><h3 id="基本步骤（开启一个web服务，获取get请求）"><a href="#基本步骤（开启一个web服务，获取get请求）" class="headerlink" title="基本步骤（开启一个web服务，获取get请求）"></a>基本步骤（开启一个web服务，获取get请求）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="comment">//2.创建一个app</span></div><div class="line"><span class="keyword">const</span> app = express() <span class="comment">//app 相当于 server</span></div><div class="line"><span class="comment">//3.请求处理响应</span></div><div class="line">app.get(<span class="string">'/index.html'</span>,(req,res)=&gt;&#123; <span class="comment">// server.on('request')</span></div><div class="line">    <span class="comment">//express中的send就相当于在前面添加了一句话 res.setHeader("Content-Type","text/html;charset=utf8")</span></div><div class="line">    res.send(<span class="string">"&lt;h1&gt;我是好人&lt;/h1&gt;"</span>)<span class="comment">//send只能发送string类型的数据，读取到的文件类可以toString后发送</span></div><div class="line">&#125;)</div><div class="line">app.get(<span class="string">'/login'</span>,(req,res)=&gt;&#123;</div><div class="line">    <span class="built_in">console</span>.log(req.query)</div><div class="line">    res.send(<span class="string">"登录成功"</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//4.启动web服务，开始监听</span></div><div class="line">app.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,(err)=&gt;&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start ok"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="express接受POST请求"><a href="#express接受POST请求" class="headerlink" title="express接受POST请求"></a>express接受POST请求</h3><ul>
<li>express中集成了body-parser这个第三方包，用来读取客户端发送过来的数据中的body部分<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.导入包</span></div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</div><div class="line"><span class="comment">//2.创建一个app</span></div><div class="line"><span class="keyword">const</span> app = express() <span class="comment">//app ===&gt; server</span></div><div class="line"><span class="comment">// parse application/x-www-form-urlencoded </span></div><div class="line"><span class="comment">// 代表在express中集成body-parser这个第三方包</span></div><div class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</div><div class="line"><span class="comment">//3.请求处理响应</span></div><div class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(req.body)</div><div class="line">    res.send(<span class="string">"post登录成功"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//4.启动web服务，开始监听</span></div><div class="line">app.listen(<span class="number">3000</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"start ok"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="express中路由的使用"><a href="#express中路由的使用" class="headerlink" title="express中路由的使用"></a>express中路由的使用</h3><ul>
<li>为了方便处理客户端发送过来的请求，express根据请求的路径制定了一套路由规则，将某一类地址的请求划分到一个单独的路由模块中进行处理，并且将路由中的逻辑部分抽取到另外一个控制器模块中，将所有控制器中的数据库操作封装成一个单独的数据库操作的模块中，这样既有利于代码的复用，也有利于后期维护</li>
<li>使用步骤<br>1.在主模块中导入相应的路由模块：<code>const accountRouter = require(path.join(__dirname,&#39;routers/accountRouter.js&#39;))</code><br>2.设置某个地址的请求由该路由模块处理：<code>app.use(&#39;/account&#39;,accountRouter)</code><br>3.在路由模块中创建一个路由对象：<code>const accountRouter = express.Router()</code><br>4.导入相应的控制器模块：<code>const accountCtrl = require(path.join(__dirname,&#39;../controllers/accountController.js&#39;))</code><br>5.在这个路由对象中设置接受请求的方式以及二级路由地址，将逻辑处理交给另外一个控制器模块处理<br><code>accountRouter.get(&#39;/login&#39;,accountCtrl.getLoginPage)</code>//接受二级路由为login，请求的方式为get，并且将逻辑处理交给accountCtrl.getLoginPage控制器处理<br>6.使用<code>module.exports</code>导出这个路由对象：<code>module.exports = accountRouter</code><br>7.建立一个数据库模块，将需要用到的数据库操作分成不同的方法，用exports或者moudle.exports导出，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>)</div><div class="line"><span class="keyword">const</span> MongoClient = mongodb.MongoClient</div><div class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://localhost:27017/szhmqd06'</span>;</div><div class="line"><span class="keyword">const</span> ObjectId = mongodb.ObjectId</div><div class="line">exports.ObjectId = ObjectId</div><div class="line"></div><div class="line"><span class="keyword">const</span> getDB = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;<span class="comment">//链接数据库</span></div><div class="line">    MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</div><div class="line">        callback(db)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">//暴露出一个通用的查询一个对象的方法</span></div><div class="line">exports.findOne = <span class="function">(<span class="params">collectionName,condition,callback</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">//获取db对象，通过db对象去查询数据库中的一个的操作</span></div><div class="line">    getDB(<span class="function">(<span class="params">db</span>)=&gt;</span>&#123;</div><div class="line">        <span class="comment">//获取集合</span></div><div class="line">        <span class="keyword">const</span> collection = db.collection(collectionName)</div><div class="line"></div><div class="line">        <span class="comment">//去数据库中查找一个对象</span></div><div class="line">        collection.findOne(condition,(err,doc)=&gt;&#123;</div><div class="line">            <span class="comment">//通过回调函数，将结果传递到控制器中</span></div><div class="line">            callback(doc)</div><div class="line">            db.close()</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>8.在控制器模块中导入数据库模块：<code>const databasemanager = require(path.join(__dirname,&quot;../tools/databasemanager.js&quot;))</code><br>9.在控制器中进行相关的逻辑操作，如某个路由的相关操作，引用数据库模块进行数据库的操作等</p>
<h3 id="express中间件express-session"><a href="#express中间件express-session" class="headerlink" title="express中间件express-session"></a>express中间件express-session</h3><ul>
<li>作用：当客户端访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到客户端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)，方便服务器端校验客户端的相关状态。</li>
<li>express-session的常用参数: <blockquote>
<p>secret:一个String类型的字符串，作为服务器端生成session的签名。<br>name:返回客户端的key的名称，默认为connect.sid,也可以自己设置。<br>resave:(是否允许)当客户端并行发送多个请求时，其中一个请求在另一个请求结束时对session进行修改覆盖并保存。默认为true。但是(后续版本)有可能默认失效，所以最好手动添加。<br>saveUninitialized:初始化session时是否保存到存储。默认为true， 但是(后续版本)有可能默认失效，所以最好手动添加。<br>cookie:设置返回到前端key的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。</p>
</blockquote>
</li>
<li>express-session的一些方法:<blockquote>
<p>Session.destroy():删除session，当检测到客户端关闭时调用。<br>Session.reload():当session有修改时，刷新session。<br>Session.regenerate()：将已有session初始化。<br>Session.save()：保存session。</p>
</blockquote>
</li>
<li>一个DEMO<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</div><div class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</div><div class="line"></div><div class="line">app.use(cookieParser(<span class="string">'sessiontest'</span>));</div><div class="line">app.use(session(&#123;</div><div class="line">    <span class="attr">secret</span>: <span class="string">'sessiontest'</span>,<span class="comment">//与cookieParser中的一致</span></div><div class="line">    resave: <span class="literal">true</span>,</div><div class="line">    <span class="attr">saveUninitialized</span>:<span class="literal">true</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">//修改router/index.js,第一次请求时我们保存一条用户信息。</span></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> user=&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"Chen-xy"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="string">"22"</span>,</div><div class="line">        <span class="attr">address</span>:<span class="string">"bj"</span></div><div class="line">    &#125;</div><div class="line">  req.session.user=user;</div><div class="line">  res.render(<span class="string">'index'</span>, &#123;</div><div class="line">      <span class="attr">title</span>: <span class="string">'the test for nodejs session'</span> ,</div><div class="line">      <span class="attr">name</span>:<span class="string">'sessiontest'</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//修改router/users.js，判断用户是否登陆。</span></div><div class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(req.session.user)&#123;</div><div class="line">        <span class="keyword">var</span> user=req.session.user;</div><div class="line">        <span class="keyword">var</span> name=user.name;</div><div class="line">        res.send(<span class="string">'你好'</span>+name+<span class="string">'，欢迎来到我的家园。'</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        res.send(<span class="string">'你还没有登录，先登录下再试试！'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图片验证码captchapng模块"><a href="#图片验证码captchapng模块" class="headerlink" title="图片验证码captchapng模块"></a>图片验证码captchapng模块</h2><ul>
<li>用于生成纯数字图片验证码，只支持Base64编码，DEMO：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> captchapng = <span class="built_in">require</span>(<span class="string">'captchapng'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(request.url == <span class="string">'/captcha.png'</span>) &#123;</div><div class="line">        <span class="comment">//一般情况下配合session将随机数保存到某个用于专有的一个空间中，方便做身份验证</span></div><div class="line">        <span class="keyword">var</span> p = <span class="keyword">new</span> captchapng(<span class="number">80</span>,<span class="number">30</span>,<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">9000</span>+<span class="number">1000</span>)); <span class="comment">// width,height,numeric captcha设置图片宽高及随机数</span></div><div class="line">        p.color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// First color: background (red, green, blue, alpha)背景颜色</span></div><div class="line">        p.color(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">255</span>); <span class="comment">// Second color: paint (red, green, blue, alpha)字体颜色</span></div><div class="line">        <span class="keyword">var</span> img = p.getBase64();</div><div class="line">        <span class="keyword">var</span> imgbase64 = <span class="keyword">new</span> Buffer(img,<span class="string">'base64'</span>);</div><div class="line">        response.writeHead(<span class="number">200</span>, &#123;</div><div class="line">            <span class="string">'Content-Type'</span>: <span class="string">'image/png'</span><span class="comment">//设置相应头</span></div><div class="line">        &#125;);</div><div class="line">        response.end(imgbase64);</div><div class="line">    &#125; <span class="keyword">else</span> response.end(<span class="string">''</span>);</div><div class="line">&#125;).listen(<span class="number">8181</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Web server started.\n http:\\\\127.0.0.1:8181\\captcha.png'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mongodb数据库模块"><a href="#mongodb数据库模块" class="headerlink" title="mongodb数据库模块"></a>mongodb数据库模块</h2><ul>
<li><p>连接数据库：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient</div><div class="line">  , assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"><span class="comment">// 设置需要连接的数据的url</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">'mongodb://localhost:27017/myproject'</span>;</div><div class="line"><span class="comment">// 连接数据库，回调中第一个参数为错误信息，第二个为返回的数据库对象</span></div><div class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</div><div class="line">  assert.equal(<span class="literal">null</span>, err);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected correctly to server"</span>);</div><div class="line">  db.close();<span class="comment">//通常情况下，数据库操作一旦结束就必须关闭，解除资源占用，防止数据库连接达到上限</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>增</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> insertDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取要添加的数据库表</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 插入多个，插入一个用insertOne，回调第二个参数为返回的插入的状态</span></div><div class="line">  collection.insertMany([</div><div class="line">    &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</div><div class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">3</span>, result.result.n);</div><div class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the document collection"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>删</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> deleteDocument = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 获取要删除的数据库表</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 删除一个，多个则为deleteMany，回调第二个参数为返回删除的状态</span></div><div class="line">  collection.deleteOne(&#123; <span class="attr">a</span> : <span class="number">3</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">1</span>, result.result.n);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Removed the document with the field a equal to 3"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>查</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> findDocuments = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// 设置相应的查找的表格</span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 未设置参数则为查询所有，也可以通过正则匹配如在find中设置：`&#123; name : &#123;$regex:'辣'&#125;`则为查找name字段中包含辣的所有条目</span></div><div class="line">  collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">2</span>, docs.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</div><div class="line">    <span class="built_in">console</span>.dir(docs);</div><div class="line">    callback(docs);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> updateDocument = <span class="function"><span class="keyword">function</span>(<span class="params">db, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// Get the documents collection </span></div><div class="line">  <span class="keyword">var</span> collection = db.collection(<span class="string">'documents'</span>);</div><div class="line">  <span class="comment">// 修改文档中的a=2数据，设置为b=1</span></div><div class="line">  collection.updateOne(&#123; <span class="attr">a</span> : <span class="number">2</span> &#125;</div><div class="line">    , &#123; <span class="attr">$set</span>: &#123; <span class="attr">b</span> : <span class="number">1</span> &#125; &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">    assert.equal(err, <span class="literal">null</span>);</div><div class="line">    assert.equal(<span class="number">1</span>, result.result.n);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Updated the document with the field a equal to 2"</span>);</div><div class="line">    callback(result);</div><div class="line">  &#125;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>上述增删查改都是单独的方法，使用前请配合连接数据库使用 </strong></p>
<h2 id="all和next的使用"><a href="#all和next的使用" class="headerlink" title="all和next的使用"></a>all和next的使用</h2><ul>
<li>all和next用于路由的权限设置，比如某些需要登录才能查看操作的页面，如果不设置权限就会导致数据的暴露。通常设置在主文件中<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.all(<span class="string">'/*'</span>,(req,res,next)=&gt;&#123;<span class="comment">//匹配到所有的路由</span></div><div class="line">    <span class="keyword">if</span>(req.url.includes(<span class="string">'account'</span>))&#123;</div><div class="line">        next()<span class="comment">//如果访问的是account路由则不做权限限制</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//做权限判断</span></div><div class="line">        <span class="keyword">if</span>(req.session.loginedname != <span class="literal">null</span>)&#123;</div><div class="line">            next()<span class="comment">//如果客户端以及拥有session（说明已经登陆）则不做权限限制</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有登陆则告知用户并跳转到登陆页面</span></div><div class="line">            res.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/html;charset=utf-8"</span>)</div><div class="line">            res.end(<span class="string">"&lt;script&gt;alert('请先登录');location.href='/account/login'&lt;/script&gt;"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2><h3 id="为什么需要加密："><a href="#为什么需要加密：" class="headerlink" title="为什么需要加密："></a>为什么需要加密：</h3><ul>
<li>由于http的传输无论是post或get，都不是绝对安全的，或者说只需要稍微了解HTTP劫持就能破解用户和服务器之间的数据传输，因为前者是将请求的内容明文的形式放入请求体中，后者则是直接明文的暴露在url中，这时候就需要将用户传输的数据进行加密后传输。</li>
</ul>
<h3 id="加密原理："><a href="#加密原理：" class="headerlink" title="加密原理："></a>加密原理：</h3><ul>
<li>MD5消息摘要算法(MD5 Message-Digest Algorithm),是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。经过MD5消息摘要算法得到的内容具有唯一性，好比身份证，且不可逆，于是MD5被广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。</li>
<li>由于MD5加密后的hash值具有唯一性，且不可逆，所以在客户端通过MD5加密后，将密文传输到服务器端保存在数据库中，当用户下次再输入时，通过客户端MD5加密的密文如果跟服务器端数据库匹配的一致，说明用户输入正确。</li>
<li>但是也由于唯一性，导致网路上有大量的MD5库，一些简短的信息和密码可能已经被包含在MD5库中，别人只需要通过撞库就能查询到原来的内容。</li>
</ul>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><p>1.安装MD5：<code>$ npm install md5</code><br>2.导入MD5模块：<code>var md5 = require(&#39;md5&#39;)</code><br>3.加密：<code>md5(message)</code>,message表示需要加密的内容，返回一个加密后的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/11/Node.js知识点总结/" data-id="cj4zksgrw0004ykf40i7ciriy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/11/前端常见的兼容性问题及解决方案/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/07/11/jQuery面试题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/11/前端一些常见面试问题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/前端常用插件/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/前端常见的兼容性问题及解决方案/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/Node.js知识点总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/11/jQuery面试题/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>